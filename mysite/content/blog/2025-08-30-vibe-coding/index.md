+++
title = "AI时代的软件研发思考"
description = "Thoughts about vibe coding"
date = 2025-08-30
draft = false
template = "blog/page.html"

[extra]
toc = true
+++

# 背景

最近的这些年，AI显然是处在一个加速发展和应用的阶段，记得 chatgpt 在2022年底推出之时，我身边的一些朋友（资深级）就发出了“程序员将被AI替代“的
哀嚎。2024年底 deepseek R1 横空出世，中国网民也一夜从大模型的荒漠（之前使用 chatgpt 有诸多不便）跃升为大模型使用自由，其推理能力、编码能力又
有了很大的提升。

我从2023年开始体验了github copilot这款编程助理工具，当时就有一种惊艳之感：确实，很多时候，我只需要编写一下 comment，copilot
就可以帮我完成
接下来的编码工作，尤其是在尝试一些新的编程语言，或者使用一些新的library, framework时，大幅的缩短了遗忘的查找资料，编写代码，调试的开发过程，
编码效率应该说是又很大提升的。

2024年，又开始使用 cursor ide，相比copilot, cursor在智能化上更进一步，很多时候连注释都省掉了，smart tab 在诸多时候，都想你所想，再结合
对话式交互，在编程体验上再次大幅提升。与 Copilot 相比的话，Github Copilot 只能算冷兵器时代，而 cursor 则进入到热兵器时代，开始有自动化、机械化的
感觉了。

最近，Claude Code 再次火爆出圈，我也赶上去蹭了个热度，在过去的1周时间，利用零星的时间，利用 CC
做了一些尝试。[compare-lang-performance](https://github.com/wangzaixiang/compare-lang-performance)
就是其中的一个实验项目，通过和CC进行对话式交互，最终产出了这个性能对比的测试工具。作为体验CC的一次实验，我的基本工作流程包括：

- 需求定义流程：向 CC 说明项目的基本目标，请 CC 进行详细的需求规格描述，如果你对这个 spec 不满意，可以通过多次对话交互进行修正。
- 编码流程： 让 CC 编写代码，运行测试进行验证。
- 反复迭代：
    - 增加新的功能：例如，增加新的测试语言、新的测试代码
    - 重构设计：例如将配置信息从代码中抽离出来，从 json 到 toml 到 yaml，以及多次调整配置的格式（配置项的设计）
    - 调整命令行工具的能力，包括支持新的 CLI 选项、调整输出报告的形式。
- 更新 Readme.md 文件，将测试结果同步到该文件中。

在这次体验过程中，我有意识的不去直接进行编码工作，而是尽可能的通过与 CC 交互来达成我的目的，因此，这个项目中几乎全部的代码都是
CC 编写、修正完成的。
这一点不同于之前使用 Copilot 和 Cursor 的模式：在过去的体验中，代码的主题流程、骨架都是我收工编写，AI 仅在过程中穿插协助。

虽然是一次小的尝试，还有很多的 CC 能力并没有充分利用起来，但这个体验过程带给了我一些全新的思考，我会在这片 Blog
中记录我的所思所虑，以期待能够
找到未来（不需要那么遥远，或许就是接下来的某个区间）的正确的 AI 使用模式。

# 基于 Vibe Tools 的软件开发变化

基于 Claude Code 这样的 vibe tools，相比传统软件开发会带来以下根本性变化：

## 1. 开发流程的根本性转变

### 从`敏捷模式` 转变为 `Vibe模式`

- **传统模式**：编写需求文档 → 设计方案 → 写代码 → 调试 → 修改代码的循环
  代价：
    - 团队要求高：要求全能的团队、高昂的沟通成本、管理成本
    - 沟通效率低：受限于团队人员的认知水平差异，以及传统的编写文档、方案、代码的低效率，时间效率 + 统一语言 + 认知对齐
      带来了大的鸿沟。
    - 偏爱妥协的风格：无论是调整需求、设计方案、现有代码，都受限于团队沟通和迭代效率，以及其他不确定的风险，团队更偏向于达成保守的、妥协的方案，
      以规避风险，而非大胆创新、突破。
    - 迭代速度慢：除了传统流程自身的周期长导致迭代效率慢之外，历史包袱带来的影响也非常巨大。以致与项目越往后走，单位人天的产出越来越低，而系统的复杂性则越来越高，
      形成一种恶性的反馈增强机制。

- **Vibe模式**：描述需求（对话式迭代） → AI生成（生成方案、代码、文档） → 对话式迭代优化
  有如从`瀑布式开发模式`演变为`敏捷开发模式`，再发展到`Vibe模式`时，会带来很大的变化：
    - 团队发生变化：一个人就可以成为一个超级团队（产品经理、架构师、开发工程师、测试工程师），能力全面
    - 沟通效率提升，管理成员下降。一个人的团队在这方面具有量级上的突破。
    - 追求极致成为可能的风格，没有做不到，就怕想不到。当然，这里也对架构师提出了更高的要求，你的远见、创意决定了最终的可能性。
    - 大胆重构、创新。

## 2. 规格定义前置且更加详细

### 从过程式设计转向函数式规格

- 传统开发中，很多细节在编码过程中才考虑清楚，在设计阶段过细，可能浪费大量时间，且后续实际上会偏离实际代码而成为鸡肋。

- 传统流程中，很多的方案更偏重于 How 风格的过程式设计, 而 Vibe流程中，更偏重于 What 风格的函数式风格。
  作为一名 Functional Programming 的爱好者，我的过往经验告诉我：Functional Code 具有更高的抽象层次，相比 Procedure
  Code，具有更为简单的数据流，从可读性
  到代码质量都会有明显提升。而应用到软件过程、软件方案时，也非常有效：能够提供一个明确的、清晰的、可验证的目标，远胜过陷入实现细节的过程描述（这个甚之于团队管理、与教练艺术、
  个人规划都符合相同的逻辑 ）。
  在 Vibe 模式下，这个风格就成为显学了，因为这也是你驱动 AI 工作的基本方式，为 AI 提供明确、清晰的指令，是有效产出的必备技能。

### Vibe编程中的规格类型体系

在vibe编程中，规格定义变得更加重要和详细，需要按不同层次来组织：

#### 功能层面规格

- **Use Case** - 用户使用场景和交互流程
- **User Story** - 以用户为中心的功能需求描述
- **Business Logic** - 核心业务逻辑规则
- **Workflow** - 业务流程和状态转换

#### 接口层面规格

- **CLI** - 命令行接口设计（参数、选项、输出格式）
- **API** - RESTful/GraphQL接口规范
- **UI/UX** - 用户界面交互规范（如果涉及前端）
- **Integration** - 第三方系统集成接口

#### 数据层面规格

- **Data Model/Schema** - 数据结构和关系定义
- **Database** - 数据库设计规范（表结构、索引、约束）
- **Configuration** - 配置文件格式和默认值
- **Input/Output Format** - 数据输入输出格式规范

#### 质量层面规格

- **Test Case** - 单元测试、集成测试用例
- **Performance** - 性能指标和基准测试
- **Security** - 安全策略和权限控制
- **Error Handling** - 异常处理和错误恢复策略

#### 运维层面规格

- **Logging/Monitoring** - 日志记录和监控指标
- **Deployment** - 部署流程和环境配置
- **Visibility/Observability** - 可观测性要求
- **Backup/Recovery** - 备份和恢复策略

#### 合规层面规格

- **Documentation** - 文档结构和内容要求
- **Compliance/Standards** - 行业标准和合规要求
- **Accessibility** - 可访问性规范
- **Internationalization** - 国际化和本地化要求

### Vibe编程中的关键规格类型

在vibe编程实践中，以下几类规格特别重要：

1. **Functional Specification（功能规格）** - 明确"做什么"而非"怎么做"
2. **Contract Definition（契约定义）** - API、数据格式、接口约定
3. **Quality Gates（质量门禁）** - 性能、安全、测试的明确标准
4. **Behavioral Specification（行为规格）** - 系统在各种场景下的预期行为

在 Vibe 开发中，逐渐建立一套完善的 spec 描述体系，作为对 AI 的清晰指令，必然会提升我们的开发速度、质量。

## 3. 角色和技能要求的深刻变化

### 程序员角色转变

- 从"代码编写者"变成"定义者 + 评审者 + 创意者”的转变
- 目标定义者：
    - 梳理你的目标，你能否讲清楚（讲清楚目标是成本的第一步），实际工作中，很多同学既讲不清楚目标，也不清楚自己不清楚目标，混沌前行是常态。
    - 不仅软件开发，不清楚目标几乎是人类的常态。（《高绩效教练》一书其实就是在教练这个过程）
    - 将目标从混沌态整理成为明确清晰可行的结果，其实是解决问题的最关键步骤。对于复杂的问题，你应该将这个过程单独一个阶段，利用
      AI 来帮你整理，而不是立刻投入下一阶段的工组。
    - 你需要多花一些时间来真实理解用户的业务、需求
    - 你需要多花一些时间来学习这个领域的专业知识。
    - 你需要多花一些时间来了解目前解决这一类问题的基本方法、竟品等。
- 评审者：对 AI 的回答进行思考，这是否满足了你的目标
    - 你应该是一个挑剔者，不要接受低标准的结果。可以进一步发送改进的指令，尝试一个你心目中更好的答案。
    - 如果 AI 不能给到你有效的答案，你需要重新思考自己的目标定义，给出更具体的指令，或者在关键位置上越过 AI 自己动手。
- 创意者：你定义的目标的价值越高，后续的产出就会越高。

### 技能门槛重新定义

- **降低技术门槛**：语法、API查找等技术细节不再是瓶颈
- **提高业务门槛**：对系统设计、业务逻辑的理解要求更高
- **"会提问"比"会写代码"更重要**

## 4. 一个人的团队：角色边界的消解

### 个人能力边界大幅扩展

- 一个人可以承担产品经理、架构师、开发工程师、测试工程师等多个角色
- 小团队可以完成原本需要大团队的工作
- 跨语言、跨技术栈的成本大幅降低

### 团队协作成本降低

- 对团队间沟通的依赖显著降低
- 团队管理成本和沟通成本都大幅减少
- 知识传递从"看代码学习"变成"看对话历史学习"

## 5. 开发速度和重构态度的革新

### 极大的开发加速

- 从想法到可运行原型的时间大幅缩短
- 重构成本降低，可以更频繁地调整架构
- **大胆重构，乃至彻底重新设计、重新开发，果断放弃包袱**

### 质量控制方式改变

- 传统：依靠代码审查、单元测试
- Vibe：更依靠清晰的规格定义和持续的对话验证
- AI生成的代码往往更规范，但需要把关领域特定的最佳实践

## 6. 实践技巧与方法论

### 关键技巧

- **COT (Chain of Thought)**：引导AI进行逐步推理
- **Smart Prompting**：精确描述需求和约束
- **功能规格 vs 过程规格**：描述"做什么"而非"怎么做"
- **与AI协同学习**：在对话中学习新技术
- **教导AI**：将领域知识传授给AI助手

## 7. 全面拥抱 AI 的业务变革

### 业务流程全面AI化

- **售前阶段**：AI辅助需求分析和方案设计
- **运维客服**：智能化故障诊断和用户服务
- **定制开发**：快速响应个性化需求
- **业务应用**：数据解释、AI报告生成

### 传统软件的AI重做机遇

- 以AI-first的思路重新设计传统软件
- 在业务中深度嵌入AI能力，而非简单的功能叠加
- 追求极致的用户体验设计

## 8. 学习和成长路径的重构

### 学习重心转移

- 从"学语法→学框架→做项目"变成"学需求分析→学系统设计→学AI协作"
- 更注重跨领域知识的整合能力
- 代码所有权观念淡化，更关注系统的目标设计、架构设计，更关注系统的简单行、优美性和价值。

### 新的学习方法：向 AI 发问

作为一名架构师，你可能已经在某些领域拥有了深度的理解、认知，在这些方面，你是 master，而 AI 是你的 assistant，但在你熟悉的领域之外，你的知识、
能力则可能远逊于 LLM 了。今天的 LLM 可能已经在我们所知的所有领域都是一个好学生了，而你，则只是在很狭窄的几个领域内擅长，当然，在这些领域内，
你应该比 AI 做得更好才是。

这个时候，我完全可以通过向 AI 进行发问，让其帮我整理出我最关心的一些问题的答案，有的时候，尤其是在一些具有可迁移性的领域，是非常有价值的。

比如说，我是一名资深的 JavaScript 工程师，我现在需要学习 Python，那么，我可以让 AI 帮我整理出：
- 基本的语法、数据类型、数据结构、控制流对比。
- 高级特性：如反射、元编程等对比。
通过对比的方式，来学习一门新的语言，简直是太方便了。这个案例可以查看[Python for Javascript Developers](https://github.com/wangzaixiang/learning-language/blob/main/python-for-javascript/src/introduction.md)
文档，这是我通过 AI 来编写的一篇对比两种语言的文档输出。

# Vibe 开发的护城河机制

在Vibe开发的"快速迭代"过程中，如何保证方案和代码的质量，避免重构带来的未知的问题，例如破环版本兼容等，需要建立多层次的护城河机制：

- 测试用例作为护城河: Vibe 可以帮助我们生成足够的、高质量的测试用例。这是重构的有利保障。
- 代码覆盖率测试
- lint 工具测试。对 rust 这类的语言，rustc 和 clipper 反馈的警告，都要予以关注。
- API 兼容性保证。当重构代码，而有需要保持API兼容性时，可以提供工具，检查重构前后的兼容性问题。
- 在 claude.md 中明确补充有关的原则：例如，代码风格、最佳实践、不容许的行为等等。
- 单一变更：每次对话只改变一个明确的方面，避免大幅度变更，便于代码评审、验证、快速回滚等
- 人工把关：对AI 提交的代码进行人工把关，对核心层的代码变更，更可能需要逐行检查。

这个也非常符合引文中提到的 shift-left 机制。

# Misc

## Vibe Code 的编程语言、编程范式选择

互联网上关于 AI 时代的最佳编程语言，已经有很多的争论了：
- [Typed language are better for vibecoding](https://solmaz.io/typed-languages-are-better-suited-for-vibecoding)
- [Shift-Left 式编程语言（Rust）是 AI 自动编码的最佳语言](https://mp.weixin.qq.com/s/DVxaQQqrFb6Vl3himVnAfg)
  - [What is shift-left ⬅️ programming?](https://dev.to/szabgab/what-is-shift-left-programming-5601)  在这篇文章中，作者介绍了 shift-left 
    的概念：在开发的尽早阶段（编码阶段、编译阶段、单元测试阶段 ...）越早保证质量的编程语言，就是 shift-left，这与我们传统的“测试左移”的理念是一致的，
    只是走得更远一些。
    
    - 强类型编程相比动态类型语言可以在编译时发现尽可能的问题，后者则更依赖于运行时。（当然足够的 unit testing 可以作为 shift-left 的手段）
    - 类似于 Rust 这样的强语义语言，可以避免类型安全、内存安全、并发安全、错误处理等问题，近乎达到编译通过即正确运行。
    - TDD/unit testing 相比继承测试、UAT测试有更低的成本，支持更频繁的重构和迭代。

  然而，rust 在某些领域的语义复杂性也许会给 AI 带来很大的挑战，尤其是涉及到复杂的生命周期、类型系统时，哪些让自身用户都晕头转向的类型体操，很大可能
  会让 LLM 不知所从。

- Explicit is better than implicit
  使用了较多隐式风格的编程语言，AI 理解时会带入较多的推断，阅读代码，容易产生错误，生成代码时则可能产生歧义。

  AI 的理解能力虽然强大，但其推理是基于概率和模式匹配的。隐式的行为（如 Python 的 __magic__ 方法、JavaScript 的类型强制转换、或依赖上下文的默认参数）
  会增加 AI 理解意图的难度，容易导致生成的代码不符合预期。 

- concise vs verbose

- functional vs imperative

  函数式的风格天然契合 AI：（甚至于这也非常匹配社会的分工模式：客户提出需求，供应商负责实现，领导给出目标，员工负责实现）
  - Vibe Code 自身更倾向于分工：人负责定义目标，AI 负责实现目标。 当我们给出具体的实现过程描述时，这是一个对人来说低效的过程，而且可能限制了
    AI 的选择。此外，复杂的过程描述增加了 AI 理解你的“意图”的负担，导致在细节上出错。
  - 限制副作用，清晰的数据流，可以让 AI 生成的代码更简短、易于理解，易于验证，
  - 更易于分解、组合，实现代码复用。


## 适合 Vibe Code 的任务类型
1. 修复局部的代码 Bug （安全漏洞）
2. 


# TBC

本文目前处于酝酿阶段，会持续进行追加、修改，直至定稿。

