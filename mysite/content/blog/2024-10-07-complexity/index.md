+++
title = "关于软件复杂性"
description = "关于软件复杂性"
date = 2024-10-07
draft = false
template = "blog/page.html"
+++

复杂性是软件开发中最为核心的问题，绝大多数的创新，包括方法论、工具、框架、编程语言等，都可以说是为了应对复杂性的挑战而产生的。众多软件产品、
项目往往消耗巨大的人力、财力，在解决项目中因复杂性带来的维护、BUG、安全问题上。本文收集了一些关于软件复杂性的观点，并叠加了一些个人的思考。

本文主要参考：
- [A Philosophy of Software Design](https://milkov.tech/assets/psd.pdf) 中文版：[软件设计的哲学](https://yingang.github.io/aposd2e-zh/)
  - Chapter 2: The Nature of Complexity
- [The Art of UNIX Programming](https://book.douban.com/subject/1467587/) 中文版：Unix编程艺术 (微信读书上有电子书)
  - Chapter 13: Complexity, As Simple As Possible, but No Simpler.

## 复杂性的定义
在`软件设计的哲学`一书中，对复杂性进行了如下定义：`软件的复杂性是指那些让系统难以理解的部份`：
- 难以理解：当出现问题时，难以找到问题的原因，对系统的行为难以预测。
- 难以修改：无论是添加新功能、修复BUG、优化性能，无从下手，改不动，或者修改完后引入更多的问题。

这两个问题是相互关联的，因为难以理解（无法理解其结构、流程、算法），会导致难以修改。而因为难以修改，会导致在维护的过程中，引入更多的补丁，导致
系统更为复杂，可理解能力持续下降。

## 复杂性的主要症状
1. 变更放大：对系统的一个小变更，会导致系统中的多个地方进行修改，例如，在一个网站中，修改 banner 的内容、颜色，可能会导致多个页面的修改。
   - 根源之一：重复。多个模块存在相同、相似的逻辑。当存在重复的代码、逻辑时，修改就会蔓延。
   - 根源之二：耦合：当一个模块发生变更时，会辐射到其他模块，然后继续辐射，最后形成一个巨大的变更范围。

   > Macro 是应对重复代码的一种方式。

2. 认知负荷：开发人员需要掌握多少知识，才能完成一个任务（例如调用接口、完成某个功能）。理论上，每个功能的实现，深究下去，就会涉及到计算机科学的
   各个领域，例如：操作系统、网络、数据库、编译原理、算法等，可以制造出无穷的复杂性。
   - 根源之一：缺少封装，暴露了太多的细节，加深了外部的认知负担。
   - 根源之二：缺少抽象。把众多功能特性混合在一起，构成一个 macro 模块。
   - 根源之三：不一致性。 对软件产品而言，UI、文档的不一致性会带给用户认知负担。对软件代码而言，命名、接口、行为的不一致性性，会带给维护人员
     理解代码的认知负担。不一致性与重复是密切相关的，重复会带来不一致性。
   - 根源之四：不符合直觉、惯例的设计。每个语言、框架，都有其自己形成的惯用法，最佳实践。
   
3. 未知的未知（不确定性）。在庞大的认知负荷之下，是不确定性。
  - 缺乏契约定义（边界不明确）：对输入、输出的边界、约束、规范没有明确的定义。
    - 语义不清晰。接口的行为，讲不清楚，自然实现就考虑不到，也无法进行测试覆盖。
    - 不可证明性。
  - 不完备性。系统的行为是否能覆盖契约（边界内）的全部场景，有哪些不能覆盖的场景是未知的。

> 参考 RustforRustaceans 一书第3章：Design Interfaces，是对本章内容的一个很好的注脚。
> - Unsurprising: 降低认知负荷。已经形成的惯例(idiom)、习惯的命名、基础类型（common traits）设计模式、风格，自身的合理性得到了时间的检验，
>   也因为更多的人熟悉、更丰富的文档、 更多的使用案列而减少认知负荷。
> 
> - Flexible: 设计一些通用的接口，提高代码的可复用性。基于接口，而非具体实现，使用 generic, 使用更具抽象的类型，而非具体化类型，从而增加接口的灵活性。
>   很多语言都为 Flexible 提供了支持，例如：Rust 的 trait, Java 的 interface, C++ 的 template, Scala的 Context Bound 等。
> 
> - Obvious: 通过注释、文档、类型体系、都可以提供更为明确的接口信息，从而降低认知负荷。
> 
> - Constrainted：提高确定性。强类型体系、前置条件，后置条件，不变量、断言等，对接口进行约束，提高了接口的确定性。
>
>   DBC(Design by Contract) 就是特别针对 Constrainted 的一种设计方法。有良好 DBC 实践的设计一般都会有更好的质量。

## 复杂性的分类
![img.png](img.png)

在`UNIX编程艺术`一书中，将复杂度分为3类、3个来源：
1. 复杂度种类：
   - 本质复杂度：问题领域自身的复杂性。
   - 选择复杂度：与目标需求相关的复杂性，只能通过改变工程的目标来改变复杂度。
   - 偶然复杂度：可以通过良好的设计、过程来改善的复杂度。
2. 复杂度来源之一：代码复杂度：
     
     `UNIX编程艺术`一书中，认为："代码的缺陷密度，每百行代码出错率，往往是一个与实现语言种类无关的常量。更多行的代码意味着更多的 bug，
     而调试常常是开发中最昂贵、最耗时的部分。"，这种说法放到今天，我觉得是不正确的了：
     
     > 代码行数仅是复杂度的一个指标，但相同行数的代码，仍然会有不同的复杂度，甚至差异很大。例如圈复杂度，加入了对分支路径的
     复杂度评估。在这方面，函数式编程语言（如Scala） 相比 过程式编程语言（Java）来说，有着显著的优势。
     > - 代码行数
     > - 圈复杂度（分支、路径）：FP 通过高阶函数减少了分支，降低了数据复杂度。
     > - 数据流复杂度。FP 的数据不变性，形成了 SSA(Static Single Assignment) 形式，降低了数据流复杂度。
     > - 功能密度：更高级的语言、更良好的抽象，也会带来更高的功能密度。一行代码就可以等效于低级语言、低级抽象的多行代码。
   
3. 复杂度来源之二、之三： 接口复杂度/实现复杂度
   1. MIT / New Jersey 风格 
   
      `UNIX编程艺术`一书中提到的 MIT 哲学，侧重于 接口的简单性，而 "New Jersey" 哲学，则侧重于实现的简单性。书中也提到 UNIX 的哲学是偏向于
      接口的简单性，以及处理 signal 的风格，System V 则是偏向于实现的简单性，而 BSD 偏重于接口的简单性。
   2. Simple vs Easy 
      [Executable Pseudocode that's Easy, Boring, and Fast](http://www.lihaoyi.com/post/comlihaoyiScalaExecutablePseudocodethatsEasyBoringandFast.html)
      - 可执行的伪代码。核心就是面向阅读的高可阅读性的代码。需要经常挑战的是：要完成这段功能，还可以更简单吗？
      - Easy not simple: 这里 Easy 是对使用者而言的。接口简单，才能让使用者更容易使用，simple 是对实现者而言的。
      - Boring not interesting: 作者的意思是不要搞大而全的框架，而是聚焦于一个领域，做好一个小而美的工具。
        
      [Simple made easy](https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/SimpleMadeEasy.md)
      
   早期教条的 UNIX 哲学：宁可放弃功能，也不能放弃简单性。 CLI 与 GUI 之战，就是这种哲学的体现。这也是典型的“因为脏水而丢掉孩子”的做法。
   `软件设计的哲学`一书中列举了 ed、vi、sam、emacs、wily 等文本编辑器的演进历程。

   `软件设计的哲学`一书中，更是提出了 “Deep Module” 的设置哲学，即强调：
   - 接口设计应当 smaller and simpler，从而减少依赖复杂度，认知复杂度。
   - 模块内部的实现，应该 deep，即包含更多的功能，隐藏更多的细节。而避免 proxy/adapter 这种浅层模块。

对接口设计 和 模块实现之间的平衡和取舍，有两种说法是很生动、有趣的：
- 一个糟糕的实现，如果隐藏在一个良好的接口后面，这个糟糕的实现是可以接受的。（这也是敏捷、迭代、TDD、prototype 等方法论的基础）
- 软件设计应该是外向的（面对使用者进行设计），而不是内向的（面向实现细节进行设计）：把简单（Easy）留给用户，把复杂(Complex)留给自己。
- UI(User Interface) 与 API(Application Programming Interface) 两者都是 interface，其设计哲学有诸多相似之处。
 
我在实际工作中，看到的大部份的开发者，总是习惯于内向的风格：我要如何实现这个功能。这样做会设计出糟糕的接口（缺乏抽象、使用不方便），进而又
导致内部模块的抽象度不够（做一个好的抽象是有难度的，内向的设计风格会使得我们先避开局部的复杂性，而简化接口），导致实现的整体复杂度增加。而
转为外向的风格时，我们会优先从使用者的角度来设计接口，让接口更为简单、自然、清晰。这需要更多的抽象，也需要考虑更多宏观的问题。TDD 就是一种外向
的设计风格。

对实现的复杂度，我们可以：
- 通过迭代的方式来实现，在前期，先实现一个简单的版本，或者某个原型实现。
- 在后续迭代中，逐步深化抽象、分拆化、正交化，将复杂度逐步降低。
   
随着技术的演进，今天需要转移到调用者的复杂性，未来可能会变得简单。例如，异步处理的方式，就从最早的 callback 模式，演进到 Future/Promise，
再到 async/await 模式，每一步都是将复杂性从调用者转移到实现者。

当然，在有的时候，平衡是必须的：
- 接口设计的简单性，并不是一件容易的事情，需要有很好的抽象能力。有时这种能力必须建立在目标领域的深入理解、丰富经验之上。在对目标领域不够理解
 的情况下，很难做出简单、优雅的接口设计。 所以，有时，还是需要快速前进，等踩了坑之后，你才会知道正确的设计是什么。
 
- 在部份场景下，接口的简单性会带来过高成本的实现复杂度（可能是受当前的技术、资源限制，难以突破），或者追求接口的简单性，会带来严重的性能损失，
 在这种情况下，做必要的妥协是有价值的。（`UNIX编程艺术`一书中列举了系统调用中对无法屏蔽的中断的处理方式，以及 www 中对 404-Not Found 的处理方式
 就是将一定的复杂性从实现者转移到调用者去的很好案例。）
     
## 如何降低实现复杂度：拆分（函数化、模块化、组件化）

排序算法是很有意思的算法，从最简单的冒泡排序 O(n^2) 到快速排序 O(n log(n))，其中的核心思想就是分拆，将一个大的问题分拆成小的问题，然后再组合。
在这里，当问题分解到足够小时，它就变得简单了（衍生的问题是组合的成本）。软件的复杂性或许也是如此，其复杂度与内部规模的平方成正比，通过分拆后可以转化为
准线性的增长。

三种层次的拆分：
- 模块拆分（包、类、方法）：源代码层面
- 组件化：COM 是组件化的经典案例。 
- 部署拆分：微服务

一些常见的拆分方法：
- 按照领域拆分（水平拆分）：微服务：遵照康威定律，将组织结构映射到系统架构上，将不同的业务功能拆分成不同的服务。
- 按照层次拆分（垂直拆分）：前端接口层、业务流程层、业务核心层（原子服务）、数据访问层、数据存储层。
- 业务与技术拆分（基础设施拆分）：基础服务、服务治理、数据目录等。

### 原则：正交化
正交化：将分拆后的模块，在职责上进行正交化，避免重复的职能。正交化的最佳案列之一就是 WEB 的三个模块：
- HTML（DOM）：负责内容
- CSS：负责样式
- JavaScript：负责行为
  
WEB 之前的 WFC/Motif 等应用中， DOM 与 CSS 是高度混合的，我写过那种代码，相比 WEB 的开发方式，代码量要大一个数量级，是非常痛苦的，
大大的限制了 GUI 应用的开发效率。

正交化设计是一种艺术，在`UNIX编程艺术`中，提到的一个词是 SPOT(Single Point of Truth)：
> 程序员修炼之道（The Pragmatic Programmer) 针对一类特别重要的正交性明确提出了一条原则：不要重复自身 Don't Repeat Yourself，意思
> 是说：任何一个知识点在系统内部应当有一个唯一、明确、权威的表述。
  
正交化设计的另外一些场景： 将业务性代码 与 技术性代码（如任务调度、任务编排）等进行正交化。（在我们进行数据处理的 ETL 中，
就应用到这个拆分，从而大大的简化系统），一般的，业务性代码与业务需求之间有直接的映射关系，易变性强，但技术难度并不大，而技术性代码则具有
更好的通用性，可以应用于不同的业务场景，但其技术挑战性高。将这二者进行分拆，整个系统的复杂性就大为降低。
> 对复杂的系统，我们应该对业务进行抽象，将非业务性的功能从业务中分离出来。

### 拆分：业务性功能与技术性功能

在我们的某个开发项目中，涉及到一个 数据ETL 的任务，这里涉及到数据的加工处理，也涉及到多个任务之间的依赖关系处理，再牵涉到一些偏技术性的需求，
诸如并发（关注TPS、RTT指标）、监控、限流、任务取消（取消任务时释放资源）等，一开始整个任务实现得非常复杂，而且，在技术性需求的处理上很难达到预期。

对这个任务而言，本身有两方面的复杂性：
- 业务复杂性：如何正确的处理 ETL 自身。这个是这个任务的重点，有其自有的复杂性（本质复杂度）。
- 技术复杂性：调度、编排、并发、分布式锁、监控、限流、任务取消。单单任务取消这一项，就有很大的技术挑战：因为我们的产品需要适配 30+ 的数据库，
  在取消任务时，是否可以终止 SQL 的执行，从而避免这些重的 SQL 操作继续执行。

将这两个复杂度揉在一起，最后会导致显著的复杂性提升，以至于第一版是一个糟糕的实现：既复杂，又难以达成需求目标，通过将业务、技术性需求分离后，两部份
功能都回归到各自的本质复杂度领域，选择合适的解决方案，最终得以简化。
  
### DSL: 使用 DSL 降低复杂性
对复杂的系统，要善于定义 DSL，建立 Domain Specific Language，使用描述式的语言，来定义 what 而非 how。实际上，DSL 语言本身
就意味着我们完成了对复杂系统的抽象，将复杂的行为转换成了更高阶抽象的描述，从而抓住了复杂之中的本质。大部份的 DSL 语言都是对某个特定复杂
领域的有效抽象：

- SQL：对关系型数据库的操作抽象
- 工作流：对任务编排的抽象
- React/Vue: 通过类 JSX 或 template 的方式，对 UI 进行抽象（注意这里的描述性，而非操作性）。
- Makefile/Maven/SBT/Cargo: 对项目构建的抽象
- IDL: 对接口定义的抽象
- Regular Expression: 对字符串匹配的抽象
  
如果能够定义出 DSL，并用于描述系统的逻辑行为时，系统的复杂性会大为降低。

### 易变性(Volatility)拆分
  
每个复杂的系统，都有一些部件是易变的：会随着时间、空间的变化而演变，其自身具有不稳定性。一般来说，易变性的部件，是导致系统复杂性提升的重要原因。
- 对 SAAS 类应用，为不同的客户提供不同的功能。例如，零售系统针对不同的业态提供不同的服务模式。
- 对 电商类应用，随着业务模式的改变，会有不同的客户服务策略、营销策略、会员策略等。
- 对 OLAP 类应用，需要接入不同的数据源，面对不同数据源之间对 SQL 支持的差异。
- 对 Dashboard 类应用，需要面对不同的数据展示需求
  
对这类系统，我们就需要重点关注如何抽象这一类易变性的部件，将其与稳定性的部件进行分拆，从而实现系统的简化，否则就会陷入“Copy + Modify” 的
模式，最终形成多个完全不同的系统，维护成本会大大增加。

在 [Right Software](https://rightingsoftware.org) 一书中，提到了避免功能性的分解，而是基于易变性的分解。
[Design for change](https://seccl.tech/guides/designing-for-change/)

动静分离，以静为干，以动为支。
1. 函数模式：将规则等易变部份转换为函数调用，用户可扩展、定制自己的函数实现，在框架层面，看到的是一个 f，仅有简单的输入、输出交互。
2. 脚本模式：与 f 相似，但 f 中会使用到框架提供的各种 API，在执行过程中会与框架有复杂的交互（尤其是可能会有改变外部的 API 调用）。
  
从复杂性中识别出哪些是稳定的、静态的内容。老子曰：重为轻根，静为躁君。在复杂的系统中，我们需要将那些稳定的、静态的内容提取出来，形成一个稳定
的主干。这一条其实与上一条：易变性拆分是相辅相成的。易变性拆分是将易变的部件提取出来，而动静分离则是将稳定的部件提取出来。

对复杂性进行分拆之后，就面临如何组合，如何治理组合的问题：
- 垂直拆分：分层
- 水平拆分：领域化

### 拆分：SOLID 原则
SOLID 原则是对软件设计的五个基本原则的总称：
- S: 单一职责原则（Single Responsibility Principle）
- O: 开闭原则（Open-Closed Principle）
- L: 里氏替换原则（Liskov Substitution Principle）
- I: 接口隔离原则（Interface Segregation Principle）
- D: 依赖反转原则（Dependency Inversion Principle）

SOLID 可以作为模块拆分的一个参考。


> 对降低复杂度的措施，后续持续更新中 ...

## 复杂性的度量


## 复杂性的应对