<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<style>
    div.mermaid {
      width: 0;
    }
</style>

  <link rel="preload" as="font" href="https://wangzaixiang.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2" type="font/woff2" crossorigin>
  <link rel="preload" as="font" href="https://wangzaixiang.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2"  type="font/woff2" crossorigin>


<link rel="stylesheet" href="https://wangzaixiang.github.io/main.css">



  
  
  
  
  
    
  

  
  
    
    
  
  
  
    
  
  
  
  
    
  
  
  


  <meta name="robots" content="index, follow">
  <meta name="googlebot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1">
  <meta name="bingbot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1">


	


	

<title>关于软件复杂性 | 程序人生</title>
<meta name="description" content="关于软件复杂性">
<link rel="canonical" href="https://wangzaixiang.github.io/blog/complexity/">


  <meta name="twitter:card" content="summary_large_image">
  
    <meta name="twitter:image" content="https://wangzaixiang.github.io/doks.png">
  
  <meta name="twitter:title" content="关于软件复杂性">
  <meta name="twitter:description" content="关于软件复杂性">
  <meta name="twitter:site" content="@wangzaixiang">
  <meta name="twitter:creator" content="@wangzaixiang">
  
  <meta property="og:title" content="关于软件复杂性">
  <meta property="og:description" content="关于软件复杂性">
  <meta property="og:type" content="article">
  <meta property="og:url" content="https://wangzaixiang.github.io/blog/complexity/">

  
    <meta property="og:image" content="https://wangzaixiang.github.io/doks.png">
  

  <meta property="og:updated_time" content="">
  <meta property="og:site_name" content="关于软件复杂性">

  

  

  
  <meta property="article:publisher" content="https://www.facebook.com/ichunyun">
  <meta property="article:author" content="https://www.facebook.com/ichunyun">
  <meta property="og:locale" content="en_US">





  
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Article",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "/blog/complexity/"
      },
      "headline": "关于软件复杂性",
      "image": ,
      "datePublished": "2024-10-07",
      "dateModified": "",
      "author": {
        "@type": "Organization",
        "name": "关于软件复杂性"
      },
      "publisher": {
        "@type": "Organization",
        "name": "关于软件复杂性",
        
        "logo": {
          "@type": "ImageObject",
          "url": "/logo-doks.png"
        }
        
      },
      "description": "关于软件复杂性"
    }
    </script>
  





<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BreadcrumbList",
    
      
      
        
        
        
        
        
        
        
        
          {
            "@type": "ListItem",
            "position":  1 ,
            "name": "Home",
            "item": "https://wangzaixiang.github.io/"
          },
          
          
          {
            "@type": "ListItem",
            "position":  2 ,
            "name": "Blog",
            "item": "https://wangzaixiang.github.io/blog/"
          },
        
      
        
        
        
        
        
        
        
        
          
          
          {
            "@type": "ListItem",
            "position":  3 ,
            "name": "Complexity",
            "item": "https://wangzaixiang.github.io/blog/complexity/"
          },
        
      
    
  }
</script>







  <meta name="theme-color" content="#fff">
  <link rel="apple-touch-icon" sizes="180x180" href="https://wangzaixiang.github.io/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://wangzaixiang.github.io/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://wangzaixiang.github.io/favicon-16x16.png">
  


  

</head>

  

<body class="blog single">
  
  
<div class="header-bar fixed-top"></div>
<header class="navbar fixed-top navbar-expand-md navbar-light">
	<div class="container">
		<input class="menu-btn order-0" type="checkbox" id="menu-btn">
		<label class="menu-icon d-md-none" for="menu-btn"><span class="navicon"></span></label>
		<a class="navbar-brand order-1 order-md-0 me-auto" href="https://wangzaixiang.github.io">程序人生</a>
		<button id="mode" class="btn btn-link order-2 order-md-4" type="button" aria-label="Toggle mode">
			<span class="toggle-dark"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></span>
			<span class="toggle-light"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg></span>
		</button>
		<ul class="navbar-nav fork-me order-3 order-md-5">
			
				
					<li class="nav-item">
						<a class="nav-link" href="https://twitter.com/wangzaixiang"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-twitter"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg><span class="ms-2 visually-hidden">Twitter</span></a>
					</li>
				
					<li class="nav-item">
						<a class="nav-link" href="https://github.com/wangzaixiang/"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg><span class="ms-2 visually-hidden">GitHub</span></a>
					</li>
				
			
		</ul>
		<div class="collapse navbar-collapse order-4 order-md-1">
			<ul class="navbar-nav main-nav me-auto order-5 order-md-2">
				
					
				
				
				
					
						<li class="nav-item blog active">
							<a class="nav-link" href="https://wangzaixiang.github.io/blog/">Blog</a>
						</li>
					
						<li class="nav-item">
							<a class="nav-link" href="https://wangzaixiang.github.io/monthly/">Monthly</a>
						</li>
					
						<li class="nav-item">
							<a class="nav-link" href="https://wangzaixiang.github.io/thoughts/">Thoughts</a>
						</li>
					
				
			</ul>
			<div class="break order-6 d-md-none"></div>
			
				<form class="navbar-form flex-grow-1 order-7 order-md-3">
					<input id="userinput" class="form-control is-search" type="search" placeholder="Search docs..."
						aria-label="Search docs..." autocomplete="off">
					<div id="suggestions" class="shadow bg-white rounded"></div>
				</form>
			
		</div>
	</div>
</header>



  
<div class="wrap container" role="document">
  <div class="content">
    <div class="row justify-content-center">
      
  
  <nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation">
  	<div class="page-links">
  			<h3>On this page</h3>
  			<nav id="TableOfContents">
  					<ul>
  							
  							<li><a href="https://wangzaixiang.github.io/blog/complexity/#1-fu-za-xing">1. 复杂性</a></li>
  							
  									<ul>
  											
  											<li><a href="https://wangzaixiang.github.io/blog/complexity/#fu-za-xing-de-ding-yi">复杂性的定义</a></li>
  											
  											<li><a href="https://wangzaixiang.github.io/blog/complexity/#fu-za-xing-de-zhu-yao-zheng-zhuang">复杂性的主要症状</a></li>
  											
  											<li><a href="https://wangzaixiang.github.io/blog/complexity/#fu-za-xing-de-fen-lei">复杂性的分类</a></li>
  											
  											<li><a href="https://wangzaixiang.github.io/blog/complexity/#fu-za-xing-de-du-liang">复杂性的度量</a></li>
  											
  									</ul>
  							
  							
  							<li><a href="https://wangzaixiang.github.io/blog/complexity/#2-ru-he-jiang-di-jie-kou-fu-za-xing">2 如何降低接口复杂性</a></li>
  							
  									<ul>
  											
  											<li><a href="https://wangzaixiang.github.io/blog/complexity/#2-1-design-by-contract-zeng-qiang-jie-kou-de-que-ding-xing">2.1 Design By Contract: 增强接口的确定性</a></li>
  											
  											<li><a href="https://wangzaixiang.github.io/blog/complexity/#2-2-wai-xiang-she-ji-mian-xiang-shi-yong-zhe-de-she-ji">2.2 外向设计(面向使用者的设计)</a></li>
  											
  											<li><a href="https://wangzaixiang.github.io/blog/complexity/#2-3-yi-xie-jie-kou-she-ji-de-yuan-ze">2.3 一些接口设计的原则</a></li>
  											
  									</ul>
  							
  							
  							<li><a href="https://wangzaixiang.github.io/blog/complexity/#3-chai-fen-jiang-di-shi-xian-fu-za-du">3. 拆分：降低实现复杂度</a></li>
  							
  									<ul>
  											
  											<li><a href="https://wangzaixiang.github.io/blog/complexity/#3-1-yuan-ze-zheng-jiao-hua-chai-fen">3.1 原则：正交化拆分</a></li>
  											
  											<li><a href="https://wangzaixiang.github.io/blog/complexity/#3-2-chai-fen-ye-wu-xing-gong-neng-yu-ji-shu-xing-gong-neng">3.2 拆分：业务性功能与技术性功能</a></li>
  											
  											<li><a href="https://wangzaixiang.github.io/blog/complexity/#3-3-dsl-shi-yong-dsl-jiang-di-fu-za-xing">3.3 DSL: 使用 DSL 降低复杂性</a></li>
  											
  											<li><a href="https://wangzaixiang.github.io/blog/complexity/#3-4-yi-bian-xing-volatility-chai-fen">3.4 易变性(Volatility)拆分</a></li>
  											
  											<li><a href="https://wangzaixiang.github.io/blog/complexity/#3-5-ying-yong-solid-yuan-ze-jin-xing-chai-fen">3.5：应用 SOLID 原则进行拆分</a></li>
  											
  									</ul>
  							
  							
  							<li><a href="https://wangzaixiang.github.io/blog/complexity/#4-visibility-makes-software-simplicity">4. visibility makes software simplicity</a></li>
  							
  							
  							<li><a href="https://wangzaixiang.github.io/blog/complexity/#5-ying-yong-functional-programming-jiang-di-bian-cheng-fu-za-du">5. 应用 Functional Programming 降低编程复杂度</a></li>
  							
  									<ul>
  											
  											<li><a href="https://wangzaixiang.github.io/blog/complexity/#5-1-han-shu-shi-bian-cheng-ju-you-geng-gao-de-gong-neng-mi-du">5.1 函数式编程具有更高的功能密度。</a></li>
  											
  									</ul>
  							
  							
  							<li><a href="https://wangzaixiang.github.io/blog/complexity/#6-ying-yong-unit-test-ci-cd-jiang-di-xi-tong-bu-shu-fu-za-du">6. 应用 Unit Test&#x2F; CI&#x2F;CD 降低系统部署复杂度</a></li>
  							
  							
  					</ul>
  			</nav>
  	</div>
  </nav>
  

      <div class="col-md-12 col-lg-10 col-xxl-12">



        <article>
          <div class="blog-header">
            <h1>关于软件复杂性</h1>
            <nav style="display: flex; justify-content: space-between">
              
              <a href="https://wangzaixiang.github.io/blog/simd-sort/"> ⇦ Previous </a>
              

              
<p><small>Posted October  7, 2024&nbsp;&hyphen;&nbsp;<strong>32&nbsp;min read</strong></small></p>


              
              <a href="https://wangzaixiang.github.io/blog/learning-llvm/"> Next ⇨ </a>
              
            </nav>

          </div>
          
          <p>复杂性是软件开发中最为核心的问题，绝大多数的创新，包括方法论、工具、框架、编程语言等，都可以说是为了应对复杂性的挑战而产生的。众多软件产品、
项目往往消耗巨大的人力、财力，在解决项目中因复杂性带来的维护、BUG、安全问题上。本文收集了一些关于软件复杂性的观点，并叠加了一些个人的思考。</p>
<p>本文主要参考：</p>
<ul>
<li><a href="https://milkov.tech/assets/psd.pdf">A Philosophy of Software Design</a> 中文版：<a href="https://yingang.github.io/aposd2e-zh/">软件设计的哲学</a>
<ul>
<li>Chapter 2: The Nature of Complexity</li>
</ul>
</li>
<li><a href="https://book.douban.com/subject/1467587/">The Art of UNIX Programming</a> 中文版：Unix编程艺术 (微信读书上有电子书)
<ul>
<li>Chapter 13: Complexity, As Simple As Possible, but No Simpler.</li>
</ul>
</li>
<li>Rust for Rustaceans
<ul>
<li>Chapter 3: Design Interfaces</li>
</ul>
</li>
</ul>
<h1 id="1-fu-za-xing">1. 复杂性</h1>
<h2 id="fu-za-xing-de-ding-yi">复杂性的定义</h2>
<p>在<code>软件设计的哲学</code>一书中，对复杂性进行了如下定义：<code>软件的复杂性是指那些让系统难以理解的部份</code>：</p>
<ul>
<li>难以理解：当出现问题时，难以找到问题的原因，对系统的行为难以预测。</li>
<li>难以修改：无论是添加新功能、修复BUG、优化性能，无从下手，改不动，或者修改完后引入更多的问题。</li>
</ul>
<p>这两个问题是相互关联的，因为难以理解（无法理解其结构、流程、算法），会导致难以修改。而因为难以修改，会导致在维护的过程中，引入更多的补丁，导致
系统更为复杂，可理解能力持续下降。</p>
<h2 id="fu-za-xing-de-zhu-yao-zheng-zhuang">复杂性的主要症状</h2>
<ol>
<li>
<p>变更放大：对系统的一个小变更，会导致系统中的多个地方进行修改，例如，在一个网站中，修改 banner 的内容、颜色，可能会导致多个页面的修改。</p>
<ul>
<li>根源之一：重复。多个模块存在相同、相似的逻辑。当存在重复的代码、逻辑时，修改就会蔓延。</li>
<li>根源之二：耦合：当一个模块发生变更时，会辐射到其他模块，然后继续辐射，最后形成一个巨大的变更范围。</li>
</ul>
<blockquote>
<p>Macro 是应对重复代码的一种方式。</p>
</blockquote>
</li>
<li>
<p>认知负荷：开发人员需要掌握多少知识，才能完成一个任务（例如调用接口、完成某个功能）。理论上，每个功能的实现，深究下去，就会涉及到计算机科学的
各个领域，例如：操作系统、网络、数据库、编译原理、算法等，可以制造出无穷的复杂性。</p>
<ul>
<li>根源之一：缺少封装，暴露了太多的细节，加深了外部的认知负担。</li>
<li>根源之二：缺少抽象。把众多功能特性混合在一起，构成一个 macro 模块。</li>
<li>根源之三：不一致性。 对软件产品而言，UI、文档的不一致性会带给用户认知负担。对软件代码而言，命名、接口、行为的不一致性性，会带给维护人员
理解代码的认知负担。不一致性与重复是密切相关的，重复会带来不一致性。</li>
<li>根源之四：不符合直觉、惯例的设计。每个语言、框架，都有其自己形成的惯用法，最佳实践。</li>
</ul>
</li>
<li>
<p>未知的未知（不确定性）。在庞大的认知负荷之下，是不确定性。</p>
</li>
</ol>
<ul>
<li>缺乏契约定义（边界不明确）：对输入、输出的边界、约束、规范没有明确的定义。
<ul>
<li>语义不清晰。接口的行为，讲不清楚，自然实现就考虑不到，也无法进行测试覆盖。</li>
<li>不可证明性。</li>
</ul>
</li>
<li>不完备性。系统的行为是否能覆盖契约（边界内）的全部场景，有哪些不能覆盖的场景是未知的。</li>
</ul>
<h2 id="fu-za-xing-de-fen-lei">复杂性的分类</h2>

<img src="https:&#x2F;&#x2F;wangzaixiang.github.io&#x2F;processed_images&#x2F;img.a692be447cc4c1ba.png" />
<p>在<code>UNIX编程艺术</code>一书中，将复杂度分为3类、3个来源：</p>
<ol>
<li>
<p>复杂度种类：</p>
<ul>
<li>本质复杂度：问题领域自身的复杂性。</li>
<li>选择复杂度：与目标需求相关的复杂性，只能通过改变工程的目标来改变复杂度。</li>
<li>偶然复杂度：可以通过良好的设计、过程来改善的复杂度。</li>
</ul>
</li>
<li>
<p>复杂度来源之一：代码复杂度：</p>
<p><code>UNIX编程艺术</code>一书中，认为："代码的缺陷密度，每百行代码出错率，往往是一个与实现语言种类无关的常量。更多行的代码意味着更多的 bug，
而调试常常是开发中最昂贵、最耗时的部分。"，这种说法放到今天，我觉得是不正确的了：</p>
<blockquote>
<p>代码行数仅是复杂度的一个指标，但相同行数的代码，仍然会有不同的复杂度，甚至差异很大。例如圈复杂度，加入了对分支路径的
复杂度评估。在这方面，函数式编程语言（如Scala） 相比 过程式编程语言（Java）来说，有着显著的优势。</p>
<ul>
<li>代码行数</li>
<li>圈复杂度（分支、路径）：FP 通过高阶函数减少了分支，降低了数据复杂度。</li>
<li>数据流复杂度。FP 的数据不变性，形成了 SSA(Static Single Assignment) 形式，降低了数据流复杂度。</li>
<li>功能密度：更高级的语言、更良好的抽象，也会带来更高的功能密度。一行代码就可以等效于低级语言、低级抽象的多行代码。</li>
</ul>
</blockquote>
</li>
<li>
<p>复杂度来源之二、之三： 接口复杂度/实现复杂度</p>
<ol>
<li>
<p>MIT / New Jersey 风格</p>
<p><code>UNIX编程艺术</code>一书中提到的 MIT 哲学，侧重于 接口的简单性，而 "New Jersey" 哲学，则侧重于实现的简单性。书中也提到 UNIX 的哲学是偏向于
接口的简单性，以及处理 signal 的风格，System V 则是偏向于实现的简单性，而 BSD 偏重于接口的简单性。</p>
</li>
<li>
<p>Simple vs Easy
<a href="http://www.lihaoyi.com/post/comlihaoyiScalaExecutablePseudocodethatsEasyBoringandFast.html">Executable Pseudocode that's Easy, Boring, and Fast</a></p>
<ul>
<li>可执行的伪代码。核心就是面向阅读的高可阅读性的代码。需要经常挑战的是：要完成这段功能，还可以更简单吗？</li>
<li>Easy not simple: 这里 Easy 是对使用者而言的。接口简单，才能让使用者更容易使用，simple 是对实现者而言的。</li>
<li>Boring not interesting: 作者的意思是不要搞大而全的框架，而是聚焦于一个领域，做好一个小而美的工具。</li>
</ul>
<p><a href="https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/SimpleMadeEasy.md">Simple made easy</a></p>
</li>
</ol>
<p>早期教条的 UNIX 哲学：宁可放弃功能，也不能放弃简单性。 CLI 与 GUI 之战，就是这种哲学的体现。这也是典型的“因为脏水而丢掉孩子”的做法。
<code>软件设计的哲学</code>一书中列举了 ed、vi、sam、emacs、wily 等文本编辑器的演进历程。</p>
<p><code>软件设计的哲学</code>一书中，更是提出了 “Deep Module” 的设置哲学，即强调：</p>
<ul>
<li>接口设计应当 smaller and simpler，从而减少依赖复杂度，认知复杂度。</li>
<li>模块内部的实现，应该 deep，即包含更多的功能，隐藏更多的细节。而避免 proxy/adapter 这种浅层模块。</li>
</ul>
</li>
</ol>
<h2 id="fu-za-xing-de-du-liang">复杂性的度量</h2>
<p>待补充</p>
<h1 id="2-ru-he-jiang-di-jie-kou-fu-za-xing">2 如何降低接口复杂性</h1>
<h2 id="2-1-design-by-contract-zeng-qiang-jie-kou-de-que-ding-xing">2.1 Design By Contract: 增强接口的确定性</h2>
<p>设计契约（Design by Contract）是一种软件设计方法，由 Bertrand Meyer 在 1986 年提出。Meyer 甚至创建了一门语言：Eiffel。Eiffel 语言的最大特征
就是内置了对 Contract 的支持，将 DBC 从约定变为显式的编程构件。</p>
<pre data-lang="eiffel" style="background-color:#2b303b;color:#c0c5ce;" class="language-eiffel "><code class="language-eiffel" data-lang="eiffel"><span>note
</span><span>    description: &quot;Simple bank accounts&quot;
</span><span>
</span><span>class
</span><span>    ACCOUNT
</span><span>
</span><span>feature -- Access
</span><span>
</span><span>    balance: INTEGER
</span><span>            -- Current balance
</span><span>
</span><span>    deposit_count: INTEGER
</span><span>            -- Number of deposits made since opening
</span><span>        do
</span><span>            ... As before ...
</span><span>        end
</span><span>
</span><span>feature -- Element change
</span><span>
</span><span>    deposit (sum: INTEGER)
</span><span>            -- Add `sum&#39; to account.
</span><span>        require
</span><span>            non_negative: sum &gt;= 0
</span><span>        do
</span><span>            ... As before ...
</span><span>        ensure
</span><span>            one_more_deposit: deposit_count = old deposit_count + 1
</span><span>            updated: balance = old balance + sum
</span><span>        end
</span><span>
</span><span>feature {NONE} -- Implementation
</span><span>
</span><span>    all_deposits: DEPOSIT_LIST
</span><span>            -- List of deposits since account&#39;s opening.
</span><span>
</span><span>invariant
</span><span>    consistent_balance: (all_deposits /= Void) implies
</span><span>            (balance = all_deposits . total)
</span><span>    zero_if_no_deposits: (all_deposits = Void) implies
</span><span>            (balance = 0)
</span><span>
</span><span>end -- class ACCOUNT
</span></code></pre>
<p>DBC 只要由三个部份组成：</p>
<ol>
<li>前置检查：一般是接口调用者需要保障的部份（调用者的职责）。当然，对于很多服务处理来说，前置检查也成为是服务提供者的责任。不过，一些基本的类型层面
的检查，更加建议直接通过强类型的方式来实现，在框架层进行检查，避免让服务提供者处理这类低层次的检查工作。</li>
<li>后置检查。后置检查是服务提供者在完成服务处理后，所需进行的必要检查，确保自身处理的正确性。</li>
<li>不变量。不变量是一类对象的基础契约，无论进行何种操作，都不应该破坏这种契约。</li>
</ol>
<p>现在，主流的编程语言，都没有对 DBC 的语言级显示支持，而改为使用 assert 机制来提供部份的 DBC 能力。作为接口设计的一部份，为接口（方法、对象）提供
明确的契约定义，这应该成为设计的一部份：具备清晰、良好的契约定义的接口、对象，会有更加确定的边界。而反之，缺乏契约定义的接口、对象，很可能会产出
不清晰的职责、不确定的边界，以及在 life time 中产生脏数据，从而使得后续的行为变得更为不可琢磨。</p>
<p>以 RDBMS 为例，其提供了 table/column 级上的很多 constraint：</p>
<ol>
<li>unique index 保证了数据的唯一性，防止重复数据。</li>
<li>not null 防止 null 数据进入。</li>
<li>check 约束，保证数据的合法性。部份数据库可以定义一些列上的校验表达式。如 <code>CHECK (AGE &gt;= 18)</code></li>
<li>foreign key：引用完整性。</li>
</ol>
<p>在能使用这些场景的地方，应该优先使用数据库的约束，而不是在应用层进行约束。不过，对很多互联网应用来说，由于分库分表等物理部署的约束，会限制使用
foreign key，那么也需要在应用层有相应的应对措施，避免脏数据进入系统。脏数据进入系统，本身就以为着系统存在严重的 bug，更会导致后续复杂的处理、
以及带来更多不确定的 BUG，从而使得复杂性恶化，是需要尽可能提前治理的。</p>
<p>Contract</p>
<ol>
<li>可以作为文档的一部份，为接口的使用者提供价值，</li>
<li>可以作为测试的一部份，在测试阶段、试运行阶段，作为接口的内部保护器。</li>
<li>如果不是性能关切的，应该在运行期间进行必要的契约检查。如果某些契约检查有较高的性能成本，则可以考虑异步、批量的方式进行。</li>
</ol>
<h2 id="2-2-wai-xiang-she-ji-mian-xiang-shi-yong-zhe-de-she-ji">2.2 外向设计(面向使用者的设计)</h2>
<p>对接口设计 和 模块实现之间的平衡和取舍，有两种说法是很生动、有趣的：</p>
<ul>
<li>一个糟糕的实现，如果隐藏在一个良好的接口后面，这个糟糕的实现是可以接受的。（这也是敏捷、迭代、TDD、prototype 等方法论的基础）</li>
<li>软件设计应该是外向的（面对使用者进行设计），而不是内向的（面向实现细节进行设计）：把简单（Easy）留给用户，把复杂(Complex)留给自己。</li>
<li>UI(User Interface) 与 API(Application Programming Interface) 两者都是 interface，其设计哲学有诸多相似之处。</li>
</ul>
<p>我在实际工作中，看到的大部份的开发者，总是习惯于内向的风格：我要如何实现这个功能。这样做会设计出糟糕的接口（缺乏抽象、使用不方便），进而又
导致内部模块的抽象度不够（做一个好的抽象是有难度的，内向的设计风格会使得我们先避开局部的复杂性，而简化接口），导致实现的整体复杂度增加。而
转为外向的风格时，我们会优先从使用者的角度来设计接口，让接口更为简单、自然、清晰。这需要更多的抽象，也需要考虑更多宏观的问题。TDD 就是一种外向
的设计风格。</p>
<p>对实现的复杂度，我们可以：</p>
<ul>
<li>通过迭代的方式来实现，在前期，先实现一个简单的版本，或者某个原型实现。</li>
<li>在后续迭代中，逐步深化抽象、分拆化、正交化，将复杂度逐步降低。</li>
</ul>
<p>随着技术的演进，今天需要转移到调用者的复杂性，未来可能会变得简单。例如，异步处理的方式，就从最早的 callback 模式，演进到 Future/Promise，
再到 async/await 模式，每一步都是将复杂性从调用者转移到实现者。</p>
<p>当然，在有的时候，平衡是必须的：</p>
<ul>
<li>
<p>接口设计的简单性，并不是一件容易的事情，需要有很好的抽象能力。有时这种能力必须建立在目标领域的深入理解、丰富经验之上。在对目标领域不够理解
的情况下，很难做出简单、优雅的接口设计。 所以，有时，还是需要快速前进，等踩了坑之后，你才会知道正确的设计是什么。</p>
</li>
<li>
<p>在部份场景下，接口的简单性会带来过高成本的实现复杂度（可能是受当前的技术、资源限制，难以突破），或者追求接口的简单性，会带来严重的性能损失，
在这种情况下，做必要的妥协是有价值的。（<code>UNIX编程艺术</code>一书中列举了系统调用中对无法屏蔽的中断的处理方式，以及 www 中对 404-Not Found 的处理方式
就是将一定的复杂性从实现者转移到调用者去的很好案例。）</p>
</li>
</ul>
<h2 id="2-3-yi-xie-jie-kou-she-ji-de-yuan-ze">2.3 一些接口设计的原则</h2>
<p>本节内容参考 RustforRustaceans 一书第3章：Design Interfaces，是对本章内容的一个很好的注脚。</p>
<ul>
<li>
<p>Unsurprising: 降低认知负荷。已经形成的惯例(idiom)、习惯的命名、基础类型（common traits）设计模式、风格，自身的合理性得到了时间的检验，
也因为更多的人熟悉、更丰富的文档、 更多的使用案列而减少认知负荷。</p>
<p>已有的管理、模式并非不能打破，但打破时，需要有充分的理由，而不是为了追求新奇。如果你不了解、不理解已有的模式，那么所谓的创新，很可能是低水平的
重复，既没有提供新的价值，又增加了认知负荷。</p>
</li>
<li>
<p>Flexible: 设计一些通用的接口，提高代码的可复用性。基于接口，而非具体实现，使用 generic, 使用更具抽象的类型，而非具体化类型，从而增加接口的灵活性。
很多语言都为 Flexible 提供了支持，例如：Rust 的 trait, Java 的 interface, C++ 的 template, Scala的 Context Bound 等。</p>
</li>
<li>
<p>Obvious: 通过注释、文档、类型体系、都可以提供更为明确的接口信息，从而降低认知负荷。</p>
</li>
<li>
<p>Constrainted：提高确定性。强类型体系、前置条件，后置条件，不变量、断言等，对接口进行约束，提高了接口的确定性。</p>
<p>DBC(Design by Contract) 就是特别针对 Constrainted 的一种设计方法。有良好 DBC 实践的设计一般都会有更好的质量。</p>
</li>
</ul>
<h1 id="3-chai-fen-jiang-di-shi-xian-fu-za-du">3. 拆分：降低实现复杂度</h1>
<p>排序算法是很有意思的算法，从最简单的冒泡排序 O(n^2) 到快速排序 O(n log(n))，其中的核心思想就是分拆，将一个大的问题分拆成小的问题，然后再组合。
在这里，当问题分解到足够小时，它就变得简单了（衍生的问题是组合的成本）。软件的复杂性或许也是如此，其复杂度与内部规模的平方成正比，通过分拆后可以转化为
准线性的增长。</p>
<p>拆分的核心都是围绕：解耦、内聚来进行的：减少模块间的耦合，强化模块内的聚合。</p>
<p>三种层次的拆分：</p>
<ul>
<li>模块拆分（包、类、方法）：源代码层面</li>
<li>组件化：COM 是组件化的经典案例。</li>
<li>部署拆分：微服务</li>
</ul>
<p>一些常见的拆分方法：</p>
<ul>
<li>按照领域拆分（水平拆分）：微服务：遵照康威定律，将组织结构映射到系统架构上，将不同的业务功能拆分成不同的服务。</li>
<li>按照层次拆分（垂直拆分）：前端接口层、业务流程层、业务核心层（原子服务）、数据访问层、数据存储层。</li>
<li>业务与技术拆分（基础设施拆分）：基础服务、服务治理、数据目录等。</li>
</ul>
<p>
<img src="https:&#x2F;&#x2F;wangzaixiang.github.io&#x2F;processed_images&#x2F;img_1.1e1a4c476bcf1eb4.png" />
附一张我之前对分层、分领域，易变形相关的思考图。</p>
<h2 id="3-1-yuan-ze-zheng-jiao-hua-chai-fen">3.1 原则：正交化拆分</h2>
<p>正交化：将分拆后的模块，在职责上进行正交化，避免重复的职能。正交化的最佳案列之一就是 WEB 的三个模块：</p>
<ul>
<li>HTML（DOM）：负责内容</li>
<li>CSS：负责样式</li>
<li>JavaScript：负责行为</li>
</ul>
<p>WEB 之前的 WFC/Motif 等应用中， DOM 与 CSS 是高度混合的，我写过那种代码，相比 WEB 的开发方式，代码量要大一个数量级，是非常痛苦的，
大大的限制了 GUI 应用的开发效率。</p>
<p>正交化设计是一种艺术，在<code>UNIX编程艺术</code>中，提到的一个词是 SPOT(Single Point of Truth)：</p>
<blockquote>
<p>程序员修炼之道（The Pragmatic Programmer) 针对一类特别重要的正交性明确提出了一条原则：不要重复自身 Don't Repeat Yourself，意思
是说：任何一个知识点在系统内部应当有一个唯一、明确、权威的表述。</p>
</blockquote>
<p>正交化设计的另外一些场景： 将业务性代码 与 技术性代码（如任务调度、任务编排）等进行正交化。（在我们进行数据处理的 ETL 中，
就应用到这个拆分，从而大大的简化系统），一般的，业务性代码与业务需求之间有直接的映射关系，易变性强，但技术难度并不大，而技术性代码则具有
更好的通用性，可以应用于不同的业务场景，但其技术挑战性高。将这二者进行分拆，整个系统的复杂性就大为降低。</p>
<blockquote>
<p>对复杂的系统，我们应该对业务进行抽象，将非业务性的功能从业务中分离出来。</p>
</blockquote>
<h2 id="3-2-chai-fen-ye-wu-xing-gong-neng-yu-ji-shu-xing-gong-neng">3.2 拆分：业务性功能与技术性功能</h2>
<p>在我们的某个开发项目中，涉及到一个 数据ETL 的任务，这里涉及到数据的加工处理，也涉及到多个任务之间的依赖关系处理，再牵涉到一些偏技术性的需求，
诸如并发（关注TPS、RTT指标）、监控、限流、任务取消（取消任务时释放资源）等，一开始整个任务实现得非常复杂，而且，在技术性需求的处理上很难达到预期。</p>
<p>对这个任务而言，本身有两方面的复杂性：</p>
<ul>
<li>业务复杂性：如何正确的处理 ETL 自身。这个是这个任务的重点，有其自有的复杂性（本质复杂度）。</li>
<li>技术复杂性：调度、编排、并发、分布式锁、监控、限流、任务取消。单单任务取消这一项，就有很大的技术挑战：因为我们的产品需要适配 30+ 的数据库，
在取消任务时，是否可以终止 SQL 的执行，从而避免这些重的 SQL 操作继续执行。</li>
</ul>
<p>将这两个复杂度揉在一起，最后会导致显著的复杂性提升，以至于第一版是一个糟糕的实现：既复杂，又难以达成需求目标，通过将业务、技术性需求分离后，两部份
功能都回归到各自的本质复杂度领域，选择合适的解决方案，最终得以简化。</p>
<h2 id="3-3-dsl-shi-yong-dsl-jiang-di-fu-za-xing">3.3 DSL: 使用 DSL 降低复杂性</h2>
<p>对复杂的系统，要善于定义 DSL，建立 Domain Specific Language，使用描述式的语言，来定义 what 而非 how。实际上，DSL 语言本身
就意味着我们完成了对复杂系统的抽象，将复杂的行为转换成了更高阶抽象的描述，从而抓住了复杂之中的本质。大部份的 DSL 语言都是对某个特定复杂
领域的有效抽象：</p>
<ul>
<li>SQL：对关系型数据库的操作抽象</li>
<li>工作流：对任务编排的抽象</li>
<li>React/Vue: 通过类 JSX 或 template 的方式，对 UI 进行抽象（注意这里的描述性，而非操作性）。</li>
<li>Makefile/Maven/SBT/Cargo: 对项目构建的抽象</li>
<li>IDL: 对接口定义的抽象</li>
<li>Regular Expression: 对字符串匹配的抽象</li>
</ul>
<p>如果能够定义出 DSL，并用于描述系统的逻辑行为时，系统的复杂性会大为降低。</p>
<h2 id="3-4-yi-bian-xing-volatility-chai-fen">3.4 易变性(Volatility)拆分</h2>
<p>每个复杂的系统，都有一些部件是易变的：会随着时间、空间的变化而演变，其自身具有不稳定性。一般来说，易变性的部件，是导致系统复杂性提升的重要原因。</p>
<ul>
<li>对 SAAS 类应用，为不同的客户提供不同的功能。例如，零售系统针对不同的业态提供不同的服务模式。</li>
<li>对 电商类应用，随着业务模式的改变，会有不同的客户服务策略、营销策略、会员策略等。</li>
<li>对 OLAP 类应用，需要接入不同的数据源，面对不同数据源之间对 SQL 支持的差异。</li>
<li>对 Dashboard 类应用，需要面对不同的数据展示需求</li>
</ul>
<p>对这类系统，我们就需要重点关注如何抽象这一类易变性的部件，将其与稳定性的部件进行分拆，从而实现系统的简化，否则就会陷入“Copy + Modify” 的
模式，最终形成多个完全不同的系统，维护成本会大大增加。</p>
<p>在 <a href="https://rightingsoftware.org">Right Software</a> 一书中，提到了避免功能性的分解，而是基于易变性的分解。
<a href="https://seccl.tech/guides/designing-for-change/">Design for change</a></p>
<p>动静分离，以静为干，以动为支。</p>
<ol>
<li>动态流程：基于原子性的操作，将流程的动态部份提取出来，配合脚本引擎（Script）的方式来实现动态流程。script 可能是 effect 或者 pure的。</li>
<li>动态规则：引入类似于规则引擎的机制，来解决规则的动态行。一个规则可以简单抽象为一个 f:  input -&gt; boolean (pure)</li>
<li>动态策略：类似于动态规则， f: input -&gt; output (pure)</li>
</ol>
<p>引入动态以后，整个系统的复杂性会提升，质量的管控变得更为重要，因应的措施包括：</p>
<ul>
<li>动态治理：包括监控、熔断限流、报表等</li>
<li>加强契约化，尤其是 invariants 的管理，防止核心数据出现脏数据。</li>
</ul>
<p>从复杂性中识别出哪些是稳定的、静态的内容。老子曰：重为轻根，静为躁君。在复杂的系统中，我们需要将那些稳定的、静态的内容提取出来，形成一个稳定
的主干。这一条其实与上一条：易变性拆分是相辅相成的。易变性拆分是将易变的部件提取出来，而动静分离则是将稳定的部件提取出来。</p>
<h2 id="3-5-ying-yong-solid-yuan-ze-jin-xing-chai-fen">3.5：应用 SOLID 原则进行拆分</h2>
<p>SOLID 原则是对软件设计的五个基本原则的总称：</p>
<ul>
<li>S: 单一职责原则（Single Responsibility Principle）</li>
<li>O: 开闭原则（Open-Closed Principle）</li>
<li>L: 里氏替换原则（Liskov Substitution Principle）</li>
<li>I: 接口隔离原则（Interface Segregation Principle）</li>
<li>D: 依赖反转原则（Dependency Inversion Principle）</li>
</ul>
<p>SOLID 可以作为模块拆分的一个参考。</p>
<blockquote>
<p>对降低复杂度的措施，后续持续更新中 ...</p>
</blockquote>
<h1 id="4-visibility-makes-software-simplicity">4. visibility makes software simplicity</h1>
<p>这个话题，我会单独开一个 blog 来讲述。</p>
<h1 id="5-ying-yong-functional-programming-jiang-di-bian-cheng-fu-za-du">5. 应用 Functional Programming 降低编程复杂度</h1>
<p>治理软件复杂性的一个误区就是高谈设计，而忽视编码。一个广泛的认知是：软件的复杂性主要是架构师、架构设计的问题，只要设计清晰、架构合理，就不会有大
的问题了。这也创造了诸多 PPT 文化：架构图上堆砌着高大上、时髦、新潮的技术名词，再加上丰富多彩的图标设计，但却可能是绣花枕头，败絮其中。在这方面，
传统的基建领域，应该会朴实很多：华丽的架构和艺术性的设计，在基建领域无疑就是一种价值（这一点甚于软件，软件领域第一价值还是功能需求），但好的基建，
材料、工艺、施工、质量控制等都是基础，都是有严格的标准的。相反，在软件领域，对编码的要求和标准就很相差太大了。</p>
<h2 id="5-1-han-shu-shi-bian-cheng-ju-you-geng-gao-de-gong-neng-mi-du">5.1 函数式编程具有更高的功能密度。</h2>
<p>使用代码的行数来评估代码复杂度，虽然是一个简单的纬度，但仍然具有一定的参考价值。函数式语言，具有更好的抽象能力、更强的函数组合能力（如高阶函数）</p>
<h1 id="6-ying-yong-unit-test-ci-cd-jiang-di-xi-tong-bu-shu-fu-za-du">6. 应用 Unit Test/ CI/CD 降低系统部署复杂度</h1>

        </article>

        <nav style="display: flex; justify-content: space-between">
          
          <a href="https://wangzaixiang.github.io/blog/simd-sort/"> ⇦ Previous </a>
          

          
          <a href="https://wangzaixiang.github.io/blog/learning-llvm/"> Next ⇨ </a>
          
        </nav>

      </div>
    </div>
  </div>
</div>


  
    
<footer class="footer text-muted">
	<div class="container">
		<div class="row">
			<div class="col-lg-8 order-last order-lg-first">
				<ul class="list-inline">
					
					    <!--
						<li class="list-inline-item">Powered by <a href="https://www.netlify.com/">Netlify</a>, <a href="https://www.getzola.org/">Zola</a>, and <a href="https://github.com/aaranxu/adidoks">AdiDoks</a></li>
						-->
					
				</ul>
			</div>
			<div class="col-lg-8 order-first order-lg-last text-lg-end">
				<ul class="list-inline">
					
				</ul>
			</div>
		</div>
	</div>
</footer>

  

  
<script type="text/javascript" src="https://wangzaixiang.github.io/js/main.js" defer></script>

  <script type="text/javascript" src="https://wangzaixiang.github.io/plugins/elasticlunr.min.js" defer></script>
  <script type="text/javascript" src="https://wangzaixiang.github.io/search_index.en.js" defer></script>
  <script type="text/javascript" src="https://wangzaixiang.github.io/js/search.js" defer></script>


  <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
  <script type="module">
    let elems = document.querySelectorAll("div.mermaid");
    elems.forEach(function(it) {
      it.innerHTML = it.innerHTML.replace("```mermaid", "").replace("```", "");
    });
    let theme = document.querySelector("body").classList.contains("dark") ? "dark" : "default";
    mermaid.initialize({startOnLoad: false, theme});
    await mermaid.run( { querySelector: '.mermaid' } );
    elems.forEach( it => it.style.width = "80%" );
  </script>
</body>
</html>
