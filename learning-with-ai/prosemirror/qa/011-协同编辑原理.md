# 协同编辑原理 (Collaborative Editing)

协同编辑通常被认为是富文本编辑器开发中的“终极 Boss”。ProseMirror 从设计之初就是为了解决这个问题而生的。

## 1. 核心模型：中央权威 (Central Authority)

ProseMirror 的协同编辑模型不依赖于复杂的 CRDT (无冲突复制数据类型) 或 OT (操作转换) 算法库，而是使用了一种更简单但同样强大的**中央权威**模式。

*   **版本 (Version)**: 协同编辑的核心是“版本”。服务器维护文档的当前版本号（一个递增的整数）。
*   **权威步骤 (Authority Steps)**: 服务器是事实的唯一来源。只有当 Steps 被服务器接受并分发给所有客户端时，它们才成为“确认的”历史的一部分。
*   **本地步骤 (Unconfirmed Steps)**: 客户端在等待服务器确认时，本地产生的 Steps。

## 2. 算法流程：变基 (Rebasing)

假设两个用户 Alice 和 Bob 同时在编辑版本 $V_1$ 的文档。

1.  **并发编辑**:
    *   Alice 输入 "A"，产生 Step $S_A$。本地状态变为 $V_{1} + S_A$。
    *   Bob 输入 "B"，产生 Step $S_B$。本地状态变为 $V_{1} + S_B$。

2.  **提交 (Push)**:
    *   Alice 先将 $S_A$ 发送给服务器。
    *   服务器接受 $S_A$，文档版本更新为 $V_2$ ($V_1 + S_A$)。
    *   服务器将 $S_A$ 广播给所有连接的客户端（包括 Bob）。

3.  **冲突解决 (Rebase) - Bob 端发生的事情**:
    *   Bob 接收到了来自服务器的 $S_A$。
    *   Bob 意识到自己的 $S_B$ 是基于 $V_1$ 的，但现在权威版本已经是 $V_2$ 了。
    *   **Rebase 过程**:
        1.  **Undo**: 撤销本地未确认的 $S_B$，回到 $V_1$。
        2.  **Apply Remote**: 应用服务器发来的 $S_A$，达到 $V_2$。
        3.  **Map & Reapply**: 将 $S_B$ 映射 (Map) 到 $S_A$ 之上，生成新的 $S_B'$。
        4.  应用 $S_B'$。
    *   现在 Bob 的状态是 $V_1 + S_A + S_B'$。

## 3. 数学表达

这利用了我们之前提到的 `Mapping` 技术。

$$ S_{local}' = S_{local}.\text{map}(S_{remote}) $$

ProseMirror 实际上在底层自动处理这个“撤销-应用-重做”的逻辑（通过 `prosemirror-collab` 插件），对用户来说是无感知的。

## 4. `prosemirror-collab` 插件

要启用协同编辑，你只需要引入 `prosemirror-collab` 模块。

```javascript
import { collab } from "prosemirror-collab";

// 在 EditorState 初始化时添加
plugins: [
  collab({
    version: initialVersion, // 起始版本号
    clientID: myClientID     // 唯一客户端 ID
  })
]
```

这个插件负责：
*   跟踪本地未发送的 Steps。
*   跟踪当前确认的版本号。
*   提供 `sendableSteps(state)` 函数：获取需要发送给服务器的 Steps。
*   提供 `receiveTransaction(state, steps, clientIDs)` 函数：处理从服务器接收到的 Steps。

## 5. 为什么比 OT/CRDT 简单？

*   **CRDT** 需要维护巨大的元数据来解决因果关系，对于富文本这种复杂的嵌套树结构，实现极其复杂且内存消耗大。
*   **传统 OT** 需要定义所有操作两两之间的转换规则 ($N^2$ 复杂度)。
*   **ProseMirror 的方法**: 只需要定义每个 Step 如何通过 `Mapping` 被“移动”。这大大简化了问题，因为我们只需要关注“位置”的变化，而不需要关注语义的冲突。
