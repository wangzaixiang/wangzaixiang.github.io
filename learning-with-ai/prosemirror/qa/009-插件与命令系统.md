# ProseMirror 的扩展系统：插件 (Plugins) 与 命令 (Commands)

ProseMirror 的核心库非常精简，甚至连“按下回车键换行”或“按下 Ctrl-Z 撤销”这样的功能都不是硬编码的。所有的这些交互逻辑都是通过**插件**和**命令**来实现的。

## 1. 命令 (Commands)

### 什么是 Command？

在 ProseMirror 中，Command 是一个具有特定签名的函数。它代表一个**潜在的编辑操作**。

### Command 的函数签名：

```javascript
(state: EditorState, dispatch?: (tr: Transaction) => void, view?: EditorView) => boolean
```

这个签名非常巧妙，包含了两层含义：

1.  **Dry Run (试运行)**:
    *   如果调用时只传入 `state` (不传入 `dispatch`)，Command 应该检查它**是否可以执行**。如果可以，返回 `true`；否则返回 `false`。
    *   这用于 UI 状态更新。例如，只有当 Command 返回 `true` 时，工具栏上的“加粗”按钮才应该是可点击（Active）状态。

2.  **Execute (执行)**:
    *   如果传入了 `dispatch` 函数，Command 应该执行实际的逻辑：基于 `state` 创建一个 `Transaction`，并调用 `dispatch(tr)` 来应用它。
    *   执行后通常也返回 `true`，表示已处理。

### 示例：一个简单的“删除选区”命令

```javascript
const deleteSelection = (state, dispatch) => {
  if (state.selection.empty) return false; // 如果没有选区，不执行
  if (dispatch) {
    const tr = state.tr.deleteSelection(); // 创建 Transaction
    dispatch(tr); // 分发 Transaction
  }
  return true; // 返回 true 表示该命令适用
};
```

## 2. 插件 (Plugins)

### 什么是 Plugin？

Plugin 是 ProseMirror 的终极扩展机制。它可以介入编辑器的几乎每一个生命周期环节。一个 Plugin 可以包含：

*   **State (状态)**: 插件可以定义自己的 State Field，存储在主 `EditorState` 中。
    *   例如：Undo 历史记录插件会将其历史栈存储在插件状态中。
*   **View (视图)**: 插件可以创建自定义的 UI 元素，或者更新编辑器外部的 UI。
*   **Props (属性)**: 插件可以直接向 EditorView 注入 Props，处理 DOM 事件。
    *   `handleKeyDown`: 拦截键盘按键。
    *   `handlePaste`: 拦截粘贴事件。
    *   `decorations`: 向视图添加装饰（例如：拼写错误的高亮、协同编辑的光标）。
*   **Transaction Filter / Appender**: 插件可以拦截、修改或追加 Transaction。

### Keymap Plugin (按键映射)

最常用的插件之一是 `keymap`。它将键盘按键（如 `Mod-b`, `Enter`）映射到具体的 **Command** 上。

```javascript
import { keymap } from "prosemirror-keymap";
import { undo, redo } from "prosemirror-history";

const myKeymap = keymap({
  "Mod-z": undo,
  "Mod-y": redo,
  "Enter": (state, dispatch) => { /* ...换行逻辑... */ }
});
```

## 3. 输入规则 (Input Rules)

这是另一种特殊的插件机制，用于处理**模式匹配输入**。
例如：Markdown 风格的输入。当你输入 `* ` (星号+空格) 时，自动将其转换为列表项；输入 `# ` 时，转换为标题。

ProseMirror 通过 `InputRule` 插件监听文本输入，一旦匹配到特定正则，就触发相应的 Transaction。

## 4. 为什么这么设计？

这种**Command + Plugin** 的架构体现了极致的解耦：

1.  **UI 与逻辑分离**: 工具栏按钮只负责调用 Command，它不需要知道 Command 是如何修改文档的。
2.  **组合性**: 也就是“职责链模式”。当你按下按键时，ProseMirror 会遍历所有激活的插件。第一个返回 `true` 的插件会处理该事件。这意味着你可以轻松地覆盖或扩展默认行为。
3.  **纯函数逻辑**: Command 尽量保持为纯函数（依赖 State，生成 Transaction），这使得逻辑极易测试。

## 总结

*   **Command**: 封装具体的编辑逻辑（Function），负责生成 Transaction。
*   **Plugin**: 封装编辑器的行为扩展（Object），可以包含 State、Event Handlers、Decorations 等。
*   **交互流程**: User Input -> Plugin (Keymap) -> Command -> Transaction -> New State -> View Update。
