# 插件状态管理 (Plugin State)

ProseMirror 的 `EditorState` 是不可变（Immutable）的单一数据源。这意味着不仅仅是文档内容（Doc），所有的编辑器相关状态都必须存储在这个 `EditorState` 对象中。

如果一个插件需要“记住”某些随时间变化的数据，它不能简单地将变量保存在插件的闭包或外部对象中，而必须使用 **Plugin State** 机制。

## 为什么需要 Plugin State？

1.  **单一事实来源 (Single Source of Truth)**: 编辑器的完整状态（包含文档、选区、高亮、历史记录等）应该包含在一个对象中。这样便于调试、序列化或重置。
2.  **不可变性与历史回溯**: 如果你把状态存在插件外部（例如一个全局 `let` 变量），当你执行 `Undo` 操作回退 `EditorState` 时，外部变量不会自动回退。只有存储在 `EditorState` 内部的插件状态，才能随着 Undo/Redo 正确地切换回旧值。
3.  **协同工作**: 所有的状态变更都通过 `Transaction` 驱动。插件状态的更新逻辑也是 Transaction 的一部分。

## 典型场景：高亮搜索结果 (Find & Highlight)

假设我们要实现一个“查找并高亮”的功能。

### 需求
用户输入关键词 "apple"，编辑器需要将文档中所有的 "apple" 背景标黄。

### 为什么需要 State？
这个“当前搜索的关键词”或者“计算出的高亮位置（Decorations）”就是**插件的私有状态**。
它不是文档内容的一部分（我们没有修改文档结构），而是视图层的附加信息。但是，当用户在文档上方打字插入新内容时，下方的高亮位置必须随之移动（Mapping）。

### 代码示例

```javascript
import { Plugin, PluginKey } from "prosemirror-state";
import { Decoration, DecorationSet } from "prosemirror-view";

// 1. 定义一个 Key，方便后续获取状态
export const searchPluginKey = new PluginKey("search");

// 2. 辅助函数：根据文档和关键词计算 Decorations
function findDecorations(doc, searchTerm) {
  if (!searchTerm) return DecorationSet.empty;
  const decos = [];
  doc.descendants((node, pos) => {
    if (node.isText) {
      const text = node.text;
      let index = text.indexOf(searchTerm);
      while (index > -1) {
        // 创建一个行内装饰
        decos.push(Decoration.inline(pos + index, pos + index + searchTerm.length, {
          class: "search-result-highlight"
        }));
        index = text.indexOf(searchTerm, index + 1);
      }
    }
  });
  return DecorationSet.create(doc, decos);
}

export const searchPlugin = new Plugin({
  key: searchPluginKey,

  // 3. 定义 State 字段
  state: {
    // 初始化状态
    init(_, { doc }) {
      return { searchTerm: null, decorations: DecorationSet.empty };
    },
    
    // 处理 Transaction，计算新状态
    apply(tr, prevState) {
      const meta = tr.getMeta(searchPluginKey);
      
      // 情况 A: 用户更新了搜索关键词 (通过 Dispatch 发送了 Meta)
      if (meta && meta.type === "SET_SEARCH") {
        return {
          searchTerm: meta.term,
          decorations: findDecorations(tr.doc, meta.term)
        };
      }
      
      // 情况 B: 文档内容变了 (用户打字了)，需要映射现有的装饰
      // 或者如果文档变了，我们可能想重新搜索 (取决于性能策略，这里简单演示映射)
      if (tr.docChanged) {
        // 如果有搜索词，重新计算（为了准确性）
        if (prevState.searchTerm) {
           return {
             searchTerm: prevState.searchTerm,
             decorations: findDecorations(tr.doc, prevState.searchTerm)
           };
        }
        // 或者仅仅映射旧的位置 (如果不是重新搜索逻辑)
        // return {
        //   searchTerm: prevState.searchTerm,
        //   decorations: prevState.decorations.map(tr.mapping, tr.doc)
        // };
      }

      // 没有任何变化，返回旧状态
      return prevState;
    }
  },

  // 4. 将 State 中的 Decoration 渲染到视图
  props: {
    decorations(state) {
      // 从插件状态中读取 decorations
      return this.getState(state).decorations;
    }
  }
});

// 5. 如何改变这个状态？
// 外部 UI 调用这个函数来更新搜索词
function setSearchTerm(view, term) {
  const tr = view.state.tr.setMeta(searchPluginKey, { type: "SET_SEARCH", term });
  view.dispatch(tr);
}
```

## 其他常见场景

1.  **prosemirror-history**:
    *   它的 Plugin State 存储了两个栈：`done` (撤销栈) 和 `undone` (重做栈)。
    *   每次 Transaction 应用时，它将变化推入栈中。
    *   当 EditorState 回滚时，它是通过获取旧的 State 对象实现的，历史记录也会正确对应。

2.  **Linter / 拼写检查**:
    *   异步请求后端 API 检查语法。
    *   返回结果后，通过 Transaction 更新 Plugin State，存储错误列表（Decorations）。

3.  **协同编辑 (prosemirror-collab)**:
    *   存储版本号 (Version)。
    *   存储未确认的 Steps (Unconfirmed steps)。

## 总结

当你问自己：“这个数据在用户撤销(Undo)操作后，应该回到之前的状态吗？”
*   如果是 -> **必须**放在 Plugin State 中。
*   如果不是（例如只是 UI 上是否显示一个临时的 Tooltip，与文档历史无关） -> 可以放在 React/Vue 组件状态中，或者单纯的 JS 变量中。
