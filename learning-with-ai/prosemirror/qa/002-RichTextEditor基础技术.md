# 浏览器中 Rich Text Editor 的基础技术

为了更好地理解 ProseMirror 这样的现代富文本编辑器，我们首先来回顾一下浏览器中富文本编辑器的基础技术。

传统的浏览器富文本编辑器主要依赖以下几项技术：

## 1. `contenteditable` 属性

*   **概念**: 这是 HTML 的一个全局属性，当设置在一个元素上时 (`<div contenteditable="true">` 或简写为 `<div contenteditable>`)，浏览器会将其内容变为可编辑状态。用户可以直接在页面上编辑该元素内部的文本和结构。
*   **优点**: 浏览器原生支持，实现简单，能够快速搭建基本的编辑功能。
*   **缺点**:
    *   **非标准化的行为**: 不同浏览器对 `contenteditable` 的实现差异很大，导致行为不一致，难以进行跨浏览器兼容。
    *   **DOM 结构混乱**: 浏览器会自动生成和修改 DOM 结构以响应用户的输入和格式化命令。这些自动生成的 DOM 往往不干净、不一致，甚至嵌套混乱（例如，连续加粗操作可能生成 `<b><b>text</b></b>` 而不是 `<b>text</b>`）。这给后续的解析、存储和协作编辑带来巨大挑战。
    *   **难以控制**: 开发者对用户输入和浏览器自动生成的 DOM 缺乏细粒度控制，很难强制执行特定的文档结构或样式规则。

## 2. `document.execCommand()` API

*   **概念**: 这是浏览器提供的一个用于操作 `contenteditable` 区域内容的 API。通过它，可以执行常见的富文本操作，如 `bold` (加粗), `italic` (斜体), `createLink` (创建链接), `formatBlock` (格式化块级元素) 等。
*   **优点**: 简单易用，可以直接触发浏览器原生的编辑功能。
*   **缺点**:
    *   **功能有限**: 提供的命令集相对固定，无法满足复杂的自定义需求。
    *   **行为不透明**: 开发者无法准确知道 `execCommand` 执行后对 DOM 造成了怎样的修改，这与 `contenteditable` 的缺点紧密相关。
    *   **难以撤销/重做**: 由于对 DOM 修改的不可控性，实现精确的撤销/重做历史记录非常困难。

## 3. DOM (Document Object Model) 操作

*   **概念**: 当 `contenteditable` 和 `execCommand` 无法满足需求时，开发者会直接通过 JavaScript 对 DOM 树进行增、删、改、查操作来控制编辑器内容。
*   **优点**: 提供最大的灵活性和控制力，可以实现任何复杂的编辑逻辑。
*   **缺点**:
    *   **复杂性高**: 直接操作 DOM 很容易出错，尤其是在处理选区、光标位置、跨浏览器兼容性时。
    *   **性能问题**: 频繁而大量的 DOM 操作可能导致性能瓶颈，特别是在大型文档中。
    *   **状态管理困难**: 维护编辑器内部状态与 DOM 视图之间的一致性是一个巨大的挑战。

## 4. Selection / Range API

*   **概念**: 浏览器提供了 `Selection` 和 `Range` API，用于表示用户在文档中的选区（高亮部分）和光标位置。
*   **作用**: 这是所有富文本操作的基础。无论是 `execCommand` 还是手动 DOM 操作，都需要知道用户当前操作的范围。
*   **复杂性**: 在 `contenteditable` 环境下，准确获取和设置选区通常是实现编辑功能最棘手的部分之一，因为它经常受到浏览器对 DOM 结构自动调整的影响。

## 总结

这些基础技术为构建富文本编辑器提供了起点，但也带来了**高度的不确定性、难以维护的 DOM 结构和复杂的跨浏览器兼容问题**。ProseMirror 等现代编辑器框架正是为了解决这些痛点而诞生的，它们通过引入**虚拟文档模型、标准化操作和严格的状态管理**，将开发者从底层 DOM 的泥沼中解放出来。
