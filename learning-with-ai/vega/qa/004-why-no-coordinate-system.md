# QA: 为什么 Vega 没有逻辑坐标系 (Coordinate System)？

## 问题
Vega 规范中似乎没有 `coord` (Coordinate System) 这一层，它直接使用了屏幕的物理坐标系。如果有一个逻辑坐标系，marks 使用该逻辑坐标系，那么通过逻辑坐标系与物理坐标系的映射，旋转、镜像、从笛卡尔坐标系映射到极坐标系等能力应该更容易实现。为什么 Vega 选择不设计显式的逻辑坐标系？

## 回答

这是一个非常深刻的问题，触及了 Vega 与传统图形语法（如 ggplot2）在设计哲学上的核心差异。

### 1. 现状：Vega 如何处理坐标映射？
你是对的，Vega 没有显式的全局 `Coord` 原语。它的策略是：

*   **Scale 即映射**：逻辑空间（Data Domain）到物理空间（Visual Range）的转换完全由 `Scales` 承担。Marks 直接消费 Scale 输出的像素值。
*   **形状即数据**：Vega 不会自动“弯曲”几何体。
    *   在 `ggplot2` 中，`coord_polar()` 会自动将矩形（柱状图）弯曲成扇形（饼图）。
    *   在 `Vega` 中，如果你想要极坐标效果，你必须显式选择 `arc`（弧形）标记，并使用 `pie` transform 计算角度。

### 2. 设计权衡 (Trade-off)

Vega 这种设计看似繁琐，实则是为了**底层控制力**和**性能**：

*   **显式优于隐式 (Explicit over Implicit)**：Vega 是一种“可视化汇编语言”。它倾向于让你清楚地知道每一个像素是如何计算出来的。自动的坐标系变换往往隐藏了太多细节，使得微调变得困难。
*   **性能优化**：通用的几何体形变（如将任意 SVG 路径映射到极坐标）计算成本高昂。Vega 倾向于通过专门的 Transform（如 `pie`, `stack`）预先计算好几何属性，渲染器只需按指令绘制，无需进行复杂的实时坐标变换。
*   **地理投影的特例**：对于真正复杂的坐标变换——地理地图，Vega 提供了专门的 `Projections` 模块。这其实就是 Vega 中的“逻辑坐标系”，但仅限于地理数据。

### 3. 如何实现旋转、镜像与极坐标？

虽然没有全局 `Coord`，Vega 提供了其他机制来实现这些效果：

*   **极坐标 (Polar)**：
    *   **方法**：不使用坐标系变换，而是改变 **Mark Type**。
    *   **实现**：使用 `arc` 标记代替 `rect` 标记。使用 `scale` 映射半径 (`radius`) 和角度 (`theta`)。
*   **旋转与镜像 (Rotation & Mirroring)**：
    *   **方法**：使用 **Group Mark** 作为局部坐标容器。
    *   **实现**：将 Marks 包裹在 `<group>` 中，对 Group 应用标准的仿射变换（Affine Transforms），如 `rotate`, `scale`, `translate`。
    *   **镜像**：可以通过反转 Scale 的 `range`（例如 `[width, 0]`）来实现轴的反转。

### 4. 总结对比

| 特性 | ggplot2 (传统 GoG) | Vega |
| :--- | :--- | :--- |
| **坐标系** | 全局 `Coord` 对象 (Linear, Polar, Map) | 无全局对象，依赖 `Scales` 和 `Projections` |
| **几何变换** | 坐标系自动改变几何形状 (Rect -> Arc) | 用户显式选择几何形状 (Rect vs Arc) |
| **思维模型** | "在极坐标系画柱状图" | "使用弧形标记画玫瑰图" |
| **优势** | 高层抽象，快速探索 | 底层控制，高性能，交互性强 |

Vega 认为：**坐标系的变换往往通过改变“标记类型”和“数据变换”来表达更为清晰和精确。**

---

# 追问：Coord 抽象与 GPU 加速

## 追问
从抽象的角度来看，引入 `coord` 会更简单。如果使用了 GPU 加速，性能方面是否也不成问题？

## 回答

这同样是一个极具前瞻性的技术问题。

### 1. 抽象层面的极简性 vs. 实现层面的复杂性
你是完全正确的。从**用户心智模型 (User Mental Model)** 的角度看，`coord` 是更简单的抽象。
*   用户只需思考：“我想把这个图‘卷’起来”。
*   而不需要思考：“既然我要卷起来，那我的 `rect`（矩形）必须变成 `arc`（弧形），我的 X 轴映射必须变成角度映射，我的 Y 轴映射必须变成半径映射……”

Vega 目前的做法确实把这种“认知负担”转嫁给了用户（或者更高级的编译器，如 Vega-Lite）。

### 2. GPU 加速能解决性能问题吗？
如果在 2014 年（Vega 诞生时），答案是“不能”。但在 2024 年，答案偏向“是，但也看情况”。

*   **Vertex Shader (顶点着色器) 的魔力**：
    在 WebGL/WebGPU 中，实现一个全局的非线性坐标变换（如极坐标投影）是非常廉价的。你只需要在 Vertex Shader 中写一行代码：
    ```glsl
    // 笛卡尔 -> 极坐标
    vec2 polar(vec2 cartesian) {
        float r = cartesian.y;
        float theta = cartesian.x;
        return vec2(r * cos(theta), r * sin(theta));
    }
    ```
    对于数百万个点，GPU 可以瞬间完成这个变换。

*   **为什么 Vega 还没这么做？**
    1.  **Canvas 2D 的遗留包袱**：Vega 的默认渲染器是 Canvas 2D。Canvas API 不支持这种可编程的几何变换管线。如果在 CPU 上模拟这种通用变换，对于复杂形状（如贝塞尔曲线的极坐标变换）计算量极大且数学上很麻烦（直线变曲线）。
    2.  **几何图元的拓扑改变**：简单的点变换 GPU 很在行。但是，当一个“矩形”在极坐标下变成“扇形”时，它不仅仅是顶点的移动。
        *   一个只有 4 个顶点的矩形，在极坐标下如果只移动这 4 个顶点，画出来的还是一个（扭曲的）四边形，而不是平滑的扇形弧线。
        *   为了得到平滑的弧线，你需要**Tessellation (细分)**，把矩形拆成几十个小三角形。这在渲染管线中引入了巨大的复杂性。
    3.  **交互与拾取 (Picking)**：如果图形是在 GPU 中变换的，鼠标交互（点击检测）就会变得极其困难。你需要把鼠标坐标反向映射回逻辑空间，这对于非线性变换（如地图投影）来说数学上可能很复杂或无解。

### 3. Vega 的演进方向
其实，Vega 的下一代渲染器（如基于 WebGL 的 experiment）或者像 **Deck.gl** 这样的库，正是利用 GPU 来做这些事情。

*   **Vega-Lite 的角色**：Vega 团队意识到 Vega 的“显式”太繁琐，所以开发了 Vega-Lite。在 Vega-Lite 中，虽然也没有显式的 `coord`，但它通过高层语法自动帮你生成复杂的 Vega Spec。
*   **未来展望**：随着 WebGPU 的普及，像 Wilkinson 描述的那种“任意几何体的任意坐标变换”在 Web 端实现变得越来越可行。也许未来的 Vega 版本（或其继任者）会重新引入 `Coord` 这一层。

### 总结
Vega 没有 `Coord`，主要是受限于**当时的 Web 技术栈 (Canvas 2D)** 以及**保持几何处理简单性**的工程考量。虽然 GPU 可以解决部分计算性能问题，但**几何细分**和**交互检测**依然是引入通用 `Coord` 层的核心技术难点。
