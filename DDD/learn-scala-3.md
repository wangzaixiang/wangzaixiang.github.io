---
layout: ddd
prev: learn-scala-2.html
next: learn-scala-4.html
up: learn-scala.html
---
### Phase 3: 挑战不变性
 
 在第二个阶段，我们的定义是：“Scala as better Java”，把Scala的一些好的特性用起来，重点推荐的是：
 1. 多使用 expr， 少使用 statement
 2. 多使用 Scala 集合、使用高级函数替代循环
 3. 使用 Case Class、模式匹配等特性

 在第三个阶段，我们是需要开始进入到最为艰巨的一个环节：挑战自己，改变习惯。
 
 这些习惯是我们需要摒弃的：
* 不容许使用 var，只容许使用 val
* 不容许使用 mutable 的容器，只容许使用 immutable 容器
* 不容许创建 mutable 的对象，所有的对象必须是 immutable 的。
* 不容许使用 Java Bean，没有geter/setter，只有 Case Class。
* 不容许在循环中使用 break
* 不容许在函数中使用 return，函数只能从入口开始，出口结束。
* 不实用 null, 如果变量值可以为空，使用 Option[T]

很多Java程序员估计一看到第一条约束，就会跳起来，这相当于在Java中的所有变量、字段都要申明为 final 类型。如果是这样，还怎么写代码？毕竟，随便找一个Java项目的源代码，统计一下，使用final申明的变量、字段，其比例不会超过1%

事实上，这些“约束”，其本质上，都是一个类型：不变性、确定性。
1. 所有的变量除了首次赋值，永不改变
2. 所有的对象一经创建，永不改变
3. 所有的代码，从第一行，到最后一行，顺序执行，从不例外。

> 很多程序员一看到这几行约束，就觉得不可能写出代码了。目前的程序员，几乎都是从命令式语言入手学习的，这些约束从来就不是为命令式语言准备的，C、C++、Java、C#、Javascript、PHP、Python，等等，无一不是命令式语言。命令式语言的本质就是冯诺依曼体系，就是图灵机，其核心就是：
> - 使用内存作为白板
> - 使用结构化的控制流（本质就是：顺序、分支、循环）
> - 最基本的操作，就是读内存，计算（数值计算、逻辑计算），回写内存
> - 在这里，“变化性”、“不确定性”是命令式语言的核心：变量的值在不同的代码中被读取、计算后再回写，然后再被读取、再计算后回写。
> - 同一个变量（内存）被不同位置的代码依赖（读）、更新
> - 不同的变量控制着不同的执行流程。
> 其实，要追踪这个“代码”的执行过程、“数据”的读写过程，如果你在大脑中播放一下，基本上就是一个无比复杂的“大麻花”，想解开是非常之困难的，其实，“结构化“、”面向对象“等软件工程都是尝试把这个”麻花“梳理的更顺一些。
>
> 函数式编程是”数学家”的解决方案，如果说，命令式语言式“共享内存+扭麻花”，那么，函数式编程就是“数据流 + 管道”，通过编排一个“计算”的水管网络，让数据在这个管道中单向的流动。所以，在函数式语言中，有几个很重要的特色：
>
> 1. 无副作用：一个函数就是从输入到输出的一个计算，除此之外，不应该发生什么。我把“函数”理解为一根神奇的水管，数据流入，然后流出数据，除此之外，别无依赖。
> 2. 不变性：所有的数据都是“值”，值不可改变。
> 3. 通过函数的组合来完成复杂计算。我的理解，是不同水管的一种组合、连接，从而构成一种单向的、确定的“数据”流动。

撇开上述的“玄机”，其实，要挑战这几条约束并没有想象中的困难，在我们的团队中，Java程序员一般可以在2周内完成这个挑战，方法只有一个：实践。将你在上一阶段的代码，重写到符合上述原则为止。

> TODO 后续补充一些示范代码。
> 好文推荐：如何消除循环？以及循环中的复杂数据依赖？ [从示例逐渐理解Scala尾递归](https://www.jianshu.com/p/e456c27a4366) 