<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>window function - learning</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">C++</li><li class="chapter-item expanded "><a href="cpp_optimizations.html"><strong aria-hidden="true">1.</strong> CPP Optimizations</a></li><li class="chapter-item expanded affix "><li class="part-title">rust-lang</li><li class="chapter-item expanded "><a href="rust_prefaces.html"><strong aria-hidden="true">2.</strong> Prefaces</a></li><li class="chapter-item expanded "><a href="rust_vectorization-1.html"><strong aria-hidden="true">3.</strong> compiler vectorization</a></li><li class="chapter-item expanded "><a href="rust_sugars.html"><strong aria-hidden="true">4.</strong> rust sugars</a></li><li class="chapter-item expanded "><a href="rust_type_system.html"><strong aria-hidden="true">5.</strong> rust 类型系统</a></li><li class="chapter-item expanded "><a href="rust_unsafe_cast.html"><strong aria-hidden="true">6.</strong> unsafe: cast &amp;T to &amp;mut T</a></li><li class="chapter-item expanded "><a href="rust-2025-lifecycle.html"><strong aria-hidden="true">7.</strong> lifecycle in rust 2025</a></li><li class="chapter-item expanded "><a href="rust-rc-layout.html"><strong aria-hidden="true">8.</strong> Rc layout</a></li><li class="chapter-item expanded affix "><li class="part-title">simd</li><li class="chapter-item expanded "><a href="simd-1.html"><strong aria-hidden="true">9.</strong> simd-1</a></li><li class="chapter-item expanded affix "><li class="part-title">LLVM</li><li class="chapter-item expanded "><a href="demo-llvm-ir.html"><strong aria-hidden="true">10.</strong> 从一个简单的C代码来学习LLVM-IR</a></li><li class="chapter-item expanded affix "><li class="part-title">QBE</li><li class="chapter-item expanded "><a href="qbe-1.html"><strong aria-hidden="true">11.</strong> 初始QBE</a></li><li class="chapter-item expanded "><a href="qbe-core-concepts.html"><strong aria-hidden="true">12.</strong> QBE core concepts</a></li><li class="chapter-item expanded "><a href="qbe-data-structure.html"><strong aria-hidden="true">13.</strong> QBE 核心数据结构</a></li><li class="chapter-item expanded "><a href="qbe-2.html"><strong aria-hidden="true">14.</strong> QBE 源代码阅读 1</a></li><li class="chapter-item expanded "><a href="qbe-fillrpo.html"><strong aria-hidden="true">15.</strong> QBE 源代码阅读 2: fillrpo</a></li><li class="chapter-item expanded "><a href="qbe-fillpreds.html"><strong aria-hidden="true">16.</strong> QBE 源代码阅读 3: fillrpo</a></li><li class="chapter-item expanded "><a href="qbe-promote.html"><strong aria-hidden="true">17.</strong> QBE 源代码阅读 4：promote</a></li><li class="chapter-item expanded affix "><li class="part-title">zig-lang</li><li class="chapter-item expanded "><a href="zig_misc.html"><strong aria-hidden="true">18.</strong> misc</a></li><li class="chapter-item expanded "><a href="zig_print_in_zig.html"><strong aria-hidden="true">19.</strong> understand print in zig</a></li><li class="chapter-item expanded "><a href="zig_comptime.html"><strong aria-hidden="true">20.</strong> comptime</a></li><li class="chapter-item expanded "><a href="zig_how_comptime_works.html"><strong aria-hidden="true">21.</strong> How comptime works</a></li><li class="chapter-item expanded "><a href="zig_stack_layout.html"><strong aria-hidden="true">22.</strong> Stack-Layout</a></li><li class="chapter-item expanded "><a href="zig_a_bug.html"><strong aria-hidden="true">23.</strong> A Zig Compiler Bug</a></li><li class="chapter-item expanded "><a href="zig_dynamic_construct_a_type_in_comptime.html"><strong aria-hidden="true">24.</strong> dynamic construct a type in comptime</a></li><li class="chapter-item expanded "><a href="zig_soa_test.html"><strong aria-hidden="true">25.</strong> Zig Structure of Array test</a></li><li class="chapter-item expanded affix "><li class="part-title">scala-lang</li><li class="chapter-item expanded affix "><li class="part-title">arrow + datafusion</li><li class="chapter-item expanded "><a href="arrow_array.html"><strong aria-hidden="true">26.</strong> Array</a></li><li class="chapter-item expanded "><a href="df-case-1.html"><strong aria-hidden="true">27.</strong> df-case-1</a></li><li class="chapter-item expanded "><a href="perf-vs-duckdb-1.html"><strong aria-hidden="true">28.</strong> compare-with-duckdb</a></li><li class="chapter-item expanded "><a href="sql-join.html"><strong aria-hidden="true">29.</strong> Join Performance</a></li><li class="chapter-item expanded "><a href="datafusion/hash-join.html"><strong aria-hidden="true">30.</strong> Hashjoin</a></li><li class="chapter-item expanded "><a href="datafusion/window_function.html"><strong aria-hidden="true">31.</strong> window function</a></li><li class="chapter-item expanded "><a href="datafusion-misc.html"><strong aria-hidden="true">32.</strong> datafusion-misc</a></li><li class="chapter-item expanded affix "><li class="part-title">OLAP</li><li class="chapter-item expanded "><a href="olap_cube_js.html"><strong aria-hidden="true">33.</strong> cube.js</a></li><li class="chapter-item expanded affix "><li class="part-title">AI</li><li class="chapter-item expanded "><a href="llm/handon-llm.html"><strong aria-hidden="true">34.</strong> 图解大模型：生成式AI原理与实践</a></li><li class="chapter-item expanded affix "><li class="part-title">Misc</li><li class="chapter-item expanded "><a href="webcomponent.html"><strong aria-hidden="true">35.</strong> webcomponent</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        <a href="/" class="icon-button"> Home </a>
                    </div>

                    <h1 class="menu-title">learning</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="datafusion-窗口函数执行分析"><a class="header" href="#datafusion-窗口函数执行分析">datafusion 窗口函数执行分析</a></h1>
<h2 id="api-使用窗口函数"><a class="header" href="#api-使用窗口函数">API: 使用窗口函数</a></h2>
<p>窗口函数是针对数据分析的一个 SQL 查询扩展，其执行顺序如下图中，
<img src="sql-execute-plan.png" alt="SQL 执行顺序" /></p>
<p>一般的，窗口函数的语法如下：
<img src="window_expr_grammar.png" alt="window_expr_grammar.png" />
来源：https://duckdb.org/docs/stable/sql/functions/window_functions</p>
<p>datafusion 提供了对窗口函数的支持，不过，目前的版本支持程度仍然不如 duckdb，我目前发现的问题是： frame 中目前仅支持 literal expr,
这限制了基于当前行的 dynamic range 的支持能力，例如，典型的 上年同期年累 这样的计算。</p>
<p>在 duckdb 中，可以表示为</p>
<pre><code class="language-sql">SUM( SUM(amount) ) over (order by order_date 
  range between to_days( order_date - (date_trunc('year', order_date'year') - interval 1 year)) preceding 
  and interval 1 year preceding )
</code></pre>
<p>本文分析的目的之一就是对 datafusion 的窗口函数执行机制进行研究，并评估为其添加上这类能力的可行性。</p>
<h2 id="spi创建自定义的窗口函数"><a class="header" href="#spi创建自定义的窗口函数">SPI：创建自定义的窗口函数</a></h2>
<p>datafusion 中支持4种 自定义函数：</p>
<ul>
<li>
<p>udf: scalar 函数</p>
</li>
<li>
<p>udtf: 表函数，如 csv_read 之类的函数</p>
<ul>
<li>
<p>udwf: User Define Window Function：以 partition 为单位的窗口函数</p>
<p>主要针对非聚合类的窗口函数，参见：</p>
<ol>
<li><a href="https://github.com/apache/datafusion/blob/main/datafusion-examples/examples/simple_udwf.rs">simple udwf</a></li>
<li><a href="https://github.com/apache/datafusion/blob/main/datafusion-examples/examples/advanced_udwf.rs">advanced udwf</a></li>
</ol>
<p>see: datafusion/physical-expr/src/window/standard.rs StandardWindowExpr::evaluate(按照这个源代码整理，与代码注释对应不上)</p>
<div class="table-wrapper"><table><thead><tr><th>[<code>uses_window_frame</code>]</th><th>[<code>supports_bounded_execution</code>]</th><th>[<code>include_rank</code>]</th><th>function_to_implement</th><th>functions</th></tr></thead><tbody>
<tr><td>true</td><td>*</td><td>*</td><td>[<code>evaluate</code>]</td><td>nth_value</td></tr>
<tr><td>false (default)</td><td>*</td><td>true</td><td>[<code>evaluate_all_with_rank</code>]</td><td>rank, dense_rank, cume_dist</td></tr>
<tr><td>false</td><td>*</td><td>false (default)</td><td>[<code>evaluate_all</code>]</td><td></td></tr>
</tbody></table>
</div></li>
</ul>
<p>窗口函数：</p>
<div class="table-wrapper"><table><thead><tr><th>category</th><th>functions</th><th>supported</th><th>desc</th><th>uses_window_frame</th><th>supports_bounded_execution</th><th>include_rank</th></tr></thead><tbody>
<tr><td>ranking</td><td>cume_dist</td><td>df, duckdb</td><td>累积百分比</td><td>X</td><td>X</td><td>true</td></tr>
<tr><td>ranking</td><td>dense_rank</td><td>df, duckdb</td><td>1,2,2,3 风格的排名</td><td>X</td><td>true</td><td>true</td></tr>
<tr><td>ranking</td><td>rank</td><td>df, duckdb</td><td>1,2,2,4 风格的排名</td><td>X</td><td>true</td><td>true</td></tr>
<tr><td>ranking</td><td>ntile(n)</td><td>df, duckdb</td><td>按 n 等分</td><td>X</td><td>X</td><td>X</td></tr>
<tr><td>ranking</td><td>percent_rank</td><td>df, duckdb</td><td>排名百分比</td><td>X</td><td>X</td><td>true</td></tr>
<tr><td>ranking</td><td>row_number</td><td>df, duckdb</td><td>行号</td><td>X</td><td>true</td><td>X</td></tr>
<tr><td>analytical</td><td>first_value(expr)</td><td>df, duckdb</td><td></td><td>X</td><td>X</td><td>X</td></tr>
<tr><td>analytical</td><td>lag(expr, offset, default)</td><td>df, duckdb</td><td></td><td>X</td><td>true</td><td>X</td></tr>
<tr><td>analytical</td><td>last_value(expr)</td><td>df, duckdb</td><td></td><td>X</td><td>X</td><td>X</td></tr>
<tr><td>analytical</td><td>lead(expr, offset, default)</td><td>df, duckdb</td><td></td><td>X</td><td>true</td><td>X</td></tr>
<tr><td>analytical</td><td>nth_value(expr, n)</td><td>df, duckdb</td><td></td><td>true</td><td>true</td><td>X</td></tr>
</tbody></table>
</div></li>
<li>
<p>udaf: User Define Aggregate Function
针对形如 SUM, COUNT 之类的函数，自定义函数参考：<a href="https://github.com/apache/datafusion/blob/main/datafusion-examples/examples/advanced_udaf.rs">advanced udaf</a>
核心接口是 Accumulator, GroupsAccumulator</p>
</li>
</ul>
<pre class="mermaid">classDiagram
        
        class WindowUDFImpl {
            &lt;&lt;trait&gt;&gt;
            +partition_evaluator(PartitionEvaluatorArgs args) PartitionEvaluator
        }
        class PartitionEvaluator {
                &lt;&lt;trait&gt;&gt;
                +is_causal(): bool
                +uses_window_frame(): bool
                +supports_bounded_execution(): bool
                +include_rank(): bool
                +evaluate(&amp;~ArrayRef~ values, &amp;Range~usize~ range): Result&lt;ScalarValue&gt; 
                +evaluate_all(values:&amp;~ArrayRef~, num_rows:uszie): Result&lt;ArrayRef&gt;
                +evaluate_all_with_rank(usize num_rows, &amp;[Range~usize~] ranks_in_partition) -&gt; Result&lt;ArrayRef&gt;
        }
        WindowUDFImpl .. PartitionEvaluator
        
        class AggregateUDFImpl {
            &lt;&lt;trait&gt;&gt;    
            +accumulator(AccumulatorArgs args): Result~Box~dyn Accumulator~~
            +create_groups_accumulator(AccumulatorArgs args): Result&lt;Box&lt;dyn GroupsAccumulator&gt;&gt;
        }
        
        class Accumulator {
                &lt;&lt;trait&gt;&gt;
                +update_batch(&amp;[ArrayRef]): Result&lt;()&gt;
                +retract_batch(&amp;[ArrayRef]): Result&lt;()&gt;
                +state(): Result&lt;Vec&lt;ScalaValue&gt;&gt;
                +merge_batch(&amp;[ArrayRef]): Result&lt;()&gt;
                +evaluate(): Result&lt;ScalaValue&gt;
        }
        
        class GroupsAccumulator {
            &lt;&lt;trait&gt;&gt;
            +update_batch(&amp;[ArrayRef], Option&lt;&amp;BooleanArray&gt;, usize): Result&lt;()&gt;
            +state(EmitTo): Result&lt;ArrayRef&gt;
            +merge_batch(&amp;[ArrayRef], &amp;[usize], Option&lt;&amp;BooleanArray&gt;, usize): Result&lt;()&gt;
            +evaluate(EmitTo): Result&lt;ArrayRef&gt;    
        }

    AggregateUDFImpl .. Accumulator
    AggregateUDFImpl .. GroupsAccumulator
        
</pre>
<pre class="mermaid">classDiagram
    class WindowExpr {
        &lt;&lt;trait&gt;&gt;
        +evaluate_args(batch: &amp;RecordBatch) Result~Vec&lt;ArrayRef&gt;~
        +evaluate(batch: &amp;RecordBatch) Result~ArrayRef~
        +evaluate_stateful(partition_batches: &amp;PartitionBatches, window_agg_state: &amp;mut PartitionWindowAggStates) Result~()~
    }

    note for AggregateWindowExpr &quot;for user-defined-aggregate-function&quot;
    class AggregateWindowExpr {
        &lt;&lt;trait&gt;&gt;
    }

    note for StandardWindowExpr &quot;for user-defined-window-function&quot;
    class StandardWindowExpr {
            &lt;&lt;struct&gt;&gt;
    }

    class SlidingAggregateWindowExpr {
            &lt;&lt;struct&gt;&gt;
    }

    class PlainAggregateWindowExpr {
            &lt;&lt;struct&gt;&gt;
    }

    WindowExpr &lt;|-- AggregateWindowExpr
    AggregateWindowExpr &lt;|-- SlidingAggregateWindowExpr
    AggregateWindowExpr &lt;|-- PlainAggregateWindowExpr
    WindowExpr &lt;|-- StandardWindowExpr
</pre>
<h2 id="物理计划生成选择算子windowexpr-决策树"><a class="header" href="#物理计划生成选择算子windowexpr-决策树">物理计划生成：选择算子、WindowExpr 决策树</a></h2>
<pre class="mermaid">flowchart TD
    A[ 1: function type ?] == window function ==&gt; StandardWindowExpr
    A == aggregate function ==&gt; C[frame start unbounded ?]
    A2[2: frame end bounded ?]
    A2 == unbounded following ==&gt; WA[WindowAggExec]
    A2 == bounded ==&gt; BWA[BoundedWindowAggExec]    
    C == unbounded preceding ==&gt; plain[PlainAggregateWindowExpr]
    C == bounded ==&gt; sliding[SlidingAggregateWindowExpr]
</pre>
<p>具体，可以查看如下的代码实例，通过代码的调试等方式，可以帮助我们理解不同的算子下的执行流程：</p>
<div class="table-wrapper"><table><thead><tr><th>function</th><th>operator</th><th>window expr</th><th>demo</th></tr></thead><tbody>
<tr><td>aggregate</td><td>window agg exec</td><td>plain aggregate</td><td><a href="https://github.com/wangzaixiang/vectorize_engine/blob/main/playgrounds/try_datafusion/src/bin/test_windows.rs">test_sum_1</a></td></tr>
<tr><td>aggregate</td><td>window agg exec</td><td>sliding aggregate</td><td><a href="https://github.com/wangzaixiang/vectorize_engine/blob/main/playgrounds/try_datafusion/src/bin/test_windows.rs">test_sum2</a></td></tr>
<tr><td>aggregate</td><td>bounded window agg exec</td><td>plain aggregate</td><td><a href="https://github.com/wangzaixiang/vectorize_engine/blob/main/playgrounds/try_datafusion/src/bin/test_windows.rs">test_sum4</a></td></tr>
<tr><td>aggregate</td><td>bounded window agg exec</td><td>sliding aggregate</td><td><a href="https://github.com/wangzaixiang/vectorize_engine/blob/main/playgrounds/try_datafusion/src/bin/test_windows.rs">test_sum3</a></td></tr>
</tbody></table>
</div>
<h2 id="算子-windowaggexec-分析"><a class="header" href="#算子-windowaggexec-分析">算子: WindowAggExec 分析</a></h2>
<p>根据上述分析，WindowAggExec 的 frame 形如：between bounded and unbounded following</p>
<ol>
<li>从上游获取 RecordBatch，追加到 self.batches 中，直至全部读取完成，进入到第2步。</li>
<li>将全部的 RecordBatch 合并为一个 RecordBatch</li>
<li>在 batch 上求值 sort columns (partition key, maybe + order key)</li>
<li>按照 partition key 对 batch 进行 partition，由于 batch 已经排序，因此，在batch 中每个分区的数据已经是连续存放的，一个分区的数据接着
上一个分区的数据。每个分区可以表示为 Range<usize></li>
<li>foreach partition，调用函数 WindowAggExec::compute_window_aggregates 进行窗口函数求值
<ol>
<li>foreach window_expr 调用 window_expr.evaluate(batch) 求值（多个窗口函数可以共享同一个窗口）
<ul>
<li>window_expr.evaluate(batch) : single partition, single window_exp
<ul>
<li>foreach row in batch <code>AggregateWindowExpr::get_result_column</code>
<ol>
<li>计算 当前行的 window range</li>
<li>window_expr.<code>get_aggregate_result_inside_range</code>: evaluate for single row with a range(window)
<ul>
<li>
<p>PlainAggregateWindowExpr::get_aggregate_result_inside_range: window 0..end end 是递增的</p>
<p>frame: 0 .. LAST</p>
<ol>
<li>对比 last_range，将 shift in rows 调用 accumulator.update_batch</li>
<li>获取 accumulator.evaluate</li>
</ol>
</li>
<li>
<p>SlidingAggregateWindowExpr::get_aggregate_result_inside_range:</p>
<p>frame: <em>bounded</em> .. LAST</p>
<ol>
<li>对比 last_range，将 shift out rows 调用 accumulator.retract_batch</li>
<li>将 shift in rows 调用 accumulator.update_batch</li>
<li>获取 accumulator.evaluate</li>
</ol>
</li>
<li>
<p>总之： SlidingAggregateWindowExpr::get_aggregate_result_inside_range 可以覆盖 PlainAggregateWindowExpr::get_aggregate_result_inside_range 的能力。</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="算子-boundedwindowaggexec"><a class="header" href="#算子-boundedwindowaggexec">算子： BoundedWindowAggExec</a></h2>
<p>对 frame.end 不是 unbounded following 的窗口类型，datafusion 视为 bounded window，使用 BoundedWindowAggExec 算子来处理该窗口函数的计算。</p>
<p>根据 frame.start 的不同，会选择不同类型的 WindowExpr:</p>
<ul>
<li>对标准的窗口函数（UDWF），使用 StandardWindowExpr + PartitionEvaluator:
<pre><code class="language-sql">  select *, rank() over (partition by product_id order by order_date) as rank1 from t1
</code></pre>
</li>
<li>对聚合类窗口函数（UDAF）, frame.start 是 unbounded preceding 的，使用 PlainAggregateWindowExpr + Accumulator
<pre><code class="language-sql">select *, sum(amount) over (partition by product_id order by order_date rows between unbounded preceding and 1 following) as amounts1 from t1
</code></pre>
</li>
<li>对聚合类窗口函数（UDAF）, frame.start 不是 unbounded preceding 的，使用 SlidingAggregateWindowExpr + Accumulator
<pre><code class="language-sql">select *, sum(amount) over (order by order_date range between interval '1 days' preceding and interval '1 days' following) as slide_amounts from t1
</code></pre>
</li>
</ul>
<p>执行流程：</p>
<ol>
<li>BoundedWindowAggStream 从上游读取 RecordBatch (已按 window order by 进行排序)</li>
<li>根据 RecordBatch 更新 partition_key -&gt; PartitionBatchState( record_batch )</li>
<li>调用 BoundedWindowAggStream::compute_aggregates 计算窗口函数
<ol>
<li>foreach window_expr, call window_expr.evaluate_stateful (1 window_expr, multi partition)
<ol>
<li>foreach partition, call window_expr.get_result_column (1 window_expr, 1 partition)
<ol>
<li>foreach row which is not calculated previous
<ol>
<li>计算 row 对应的 frame range</li>
<li>如果 RecordBatch 满足 frame range，则调用 window_expr.get_aggregate_result_inside_range 进行聚合求值
<ol>
<li>相比上一行的frame，对移出的行调用 accumulator::retract_batch</li>
<li>对移入的行调用 accumulator::update_batch</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct BoundedWindowAggStream {
  window_expr: Vec&lt;WindowExprRef&gt;,
  
  input_buffer: RecordBatch,
  
  partition_buffers:  PartitionBatches,   // IndexMap&lt;PartitionKey, PartitionBatchState&gt;
  window_agg_states:  Vec&lt;PartitionWindowAggStates&gt;, // indexed by window_expr, IndexMap&lt;PartitionKey, WindowState&gt;
}

struct PartitionBatchState {
  record_batch:  RecordBatch,
  most_recent_row: Option&lt;RecordBatch&gt;
  is_end: bool,
  n_out_row: usize
}

struct WindowState {
  state: WindowAggState,
  window_fn: WindowFn,      // 累加器会持有状态，通过 update_batch, retract_batch, merge_batch 更新状态
}

struct WindowAggState {
  window_frame_range: Range&lt;usize&gt;,
  window_frame_ctx:  Option&lt;WindowFrameContext&gt;,
  
  last_calculated_index: usize,
  offset_pruned_rows: usize,
  
  out_col: ArrayRef,
  n_row_result_missing: usize,
  is_end: bool
}

<span class="boring">}</span></code></pre></pre>
<pre class="mermaid">classDiagram
  class BoundedWindowAggStream {
          &lt;&lt;object&gt;&gt;
          
          window_exprs: Vec~WindowExprRef~
          
          input_buffer: RecordBatch
          finished: bool
          
  }

  class PartitionBatchState {
          &lt;&lt;object&gt;&gt;
          
          record_batch: RecordBatch
          most_recent_row: Option&lt;RecordBatch&gt;
          is_end: bool
          n_out_row: usize
  }
  
  class WindowState {
          &lt;&lt;object&gt;&gt;
          state: WindowAggState
          window_fn: WindowFn
  }
  class WindowAggState {
          &lt;&lt;object&gt;&gt;
          window_frmae_range: Range&lt;usize&gt;
          window_frame_ctx: Option&lt;WindowFrameContext&gt;
          
          last_cacluated_index: usize
          offset_pruned_rows: usize
          out_col: ArrayRef
          n_row_result_missing: usize
          is_end: bool
  }
  class WindowFn {
          &lt;&lt;object&gt;&gt;
          partition_evaluator: PartitionEvaulator
          accumulator: Accumulator
  }      
        
        

  BoundedWindowAggStream o-- PartitionBatchState : partition_buffers[PartitionKey]
  BoundedWindowAggStream o-- WindowState : window_agg_state[window_expr_idx][PartitionKey]
  
  WindowState o--  WindowAggState
  WindowState o--  WindowFn    

</pre>
<ol>
<li><code>BoundedWindowAggStream::poll_next_inner</code>
<ol>
<li>poll RecordBatch from input</li>
<li><code>BoundedWindowAggStream::compute_aggregates</code>
<ol>
<li>foreach window_expr, <code>window_expr::evaluate_stateful(partion_batches, partition_window_agg_states)</code>
<ol>
<li><code>AggregateWindowExpr::evalute_stateful</code> foreach partition
1.</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>处理过程：</p>
<ol>
<li>无需在读取了全部分区数据后，再进行窗口函数计算，可以在读入 batch 的过程中增量的处理。</li>
<li>思考：WindowAggExec 是否可以转换为 逆序后使用 BoundedWindowAggExec?</li>
</ol>
<h2 id="思考支持更为灵活的-values-between-expr-and-expr--虽然不能匹配上述的优化但在数据量不大的情况下可以有更大的表现力"><a class="header" href="#思考支持更为灵活的-values-between-expr-and-expr--虽然不能匹配上述的优化但在数据量不大的情况下可以有更大的表现力">思考：支持更为灵活的 values between expr and expr ? 虽然不能匹配上述的优化，但在数据量不大的情况下，可以有更大的表现力</a></h2>
<h2 id="思考如何高效的支持同期同期累积等功能"><a class="header" href="#思考如何高效的支持同期同期累积等功能">思考：如何高效的支持同期、同期累积等功能？</a></h2>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../datafusion/hash-join.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../datafusion-misc.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../datafusion/hash-join.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../datafusion-misc.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>


    </div>
    </body>
</html>
