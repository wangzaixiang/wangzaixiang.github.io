<!DOCTYPE HTML>
<html lang="zh-CN" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>循环依赖处理 - JavaScript 模块化开发指南</title>


        <!-- Custom HTML head -->

        <meta name="description" content="深入理解 JavaScript 模块系统：从基础概念到现代工具链">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">JavaScript 模块化开发指南</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="循环依赖处理"><a class="header" href="#循环依赖处理">循环依赖处理</a></h1>
<p>循环依赖是模块化开发中常见但复杂的问题。当两个或多个模块相互依赖时，就形成了循环依赖。ES模块系统具有处理循环依赖的能力，但理解其机制并采用正确的设计模式对于构建健壮的应用至关重要。</p>
<h2 id="什么是循环依赖"><a class="header" href="#什么是循环依赖">什么是循环依赖</a></h2>
<h3 id="基本概念"><a class="header" href="#基本概念">基本概念</a></h3>
<pre><code class="language-javascript">// 简单的循环依赖示例

// moduleA.js
import { functionB } from './moduleB.js';

export function functionA() {
    console.log('Function A called');
    return functionB();
}

// moduleB.js  
import { functionA } from './moduleA.js';  // 循环依赖！

export function functionB() {
    console.log('Function B called');
    return 'Result from B';
}

// main.js
import { functionA } from './moduleA.js';
functionA(); // 这可能会导致问题
</code></pre>
<h3 id="循环依赖的类型"><a class="header" href="#循环依赖的类型">循环依赖的类型</a></h3>
<pre><code class="language-javascript">// 1. 直接循环依赖（A → B → A）
// a.js
import { b } from './b.js';
export const a = 'a';

// b.js
import { a } from './a.js';
export const b = 'b';

// 2. 间接循环依赖（A → B → C → A）
// a.js
import { b } from './b.js';
export const a = 'a';

// b.js
import { c } from './c.js';
export const b = 'b';

// c.js
import { a } from './a.js';
export const c = 'c';

// 3. 复杂循环依赖（多个模块形成环）
// user.js
import { Order } from './order.js';
import { Product } from './product.js';

// order.js
import { User } from './user.js';
import { Product } from './product.js';

// product.js
import { User } from './user.js';
import { Order } from './order.js';
</code></pre>
<h2 id="es模块中循环依赖的行为"><a class="header" href="#es模块中循环依赖的行为">ES模块中循环依赖的行为</a></h2>
<h3 id="1-模块加载顺序"><a class="header" href="#1-模块加载顺序">1. 模块加载顺序</a></h3>
<pre><code class="language-javascript">// 演示ES模块如何处理循环依赖

// a.js
console.log('a.js start');
import { b } from './b.js';
console.log('a.js - b imported:', b);
export const a = 'value-a';
console.log('a.js end');

// b.js
console.log('b.js start');
import { a } from './a.js';
// 注意：在现代Node.js中，直接访问a会抛出ReferenceError
// console.log('b.js - a imported:', a); // ReferenceError: Cannot access 'a' before initialization

// 使用函数延迟访问来避免TDZ错误
export function getA() {
    return a; // 这里可以安全访问，因为调用时a已经初始化
}

export const b = 'value-b';
console.log('b.js end');

// main.js
import { a } from './a.js';
import { getA } from './b.js';
console.log('main.js - a:', a);
console.log('main.js - getA():', getA());

// 执行结果：
// b.js start
// b.js end
// a.js start
// a.js - b imported: value-b
// a.js end
// main.js - a: value-a
// main.js - getA(): value-a
</code></pre>
<blockquote>
<p><strong>重要提示</strong>:</p>
<ul>
<li>在现代JavaScript引擎（如Node.js v14+）中，直接访问未初始化的绑定会抛出<code>ReferenceError</code>，这是由于Temporal Dead Zone (TDZ)的保护机制</li>
<li>早期的ES模块实现可能返回<code>undefined</code>，但现代实现更加严格</li>
<li>推荐使用函数延迟访问或重构代码来避免循环依赖问题</li>
</ul>
</blockquote>
<h4 id="执行顺序解析"><a class="header" href="#执行顺序解析">执行顺序解析</a></h4>
<p>你可能会好奇：<strong>为什么执行顺序是 <code>b.js start</code> → <code>a.js start</code> → <code>main.js</code>？</strong></p>
<p>这是ES模块<strong>深度优先加载策略</strong>的结果：</p>
<ol>
<li><strong>main.js</strong> 开始执行，遇到 <code>import { a } from './a.js'</code></li>
<li>引擎暂停 main.js，开始加载 <strong>a.js</strong></li>
<li><strong>a.js</strong> 执行，遇到 <code>import { b } from './b.js'</code></li>
<li>引擎暂停 a.js，开始加载 <strong>b.js</strong></li>
<li><strong>b.js</strong> 执行，遇到 <code>import { a } from './a.js'</code></li>
<li>引擎检测到循环依赖（a.js 已在加载中），创建未初始化绑定</li>
<li><strong>b.js</strong> 继续执行完成 → 输出 “b.js start” 和 “b.js end”</li>
<li>返回 <strong>a.js</strong> 继续执行 → 输出 “a.js start” 和 “a.js end”</li>
<li>返回 <strong>main.js</strong> 继续执行 → 输出最终结果</li>
</ol>
<p><strong>调用栈演示：</strong></p>
<pre><code>时间线    调用栈状态
T1:      [main.js]
T2:      [main.js, a.js]
T3:      [main.js, a.js, b.js]
T4:      [main.js, a.js, b.js] ← 检测循环依赖
T5:      [main.js, a.js] ← b.js 完成
T6:      [main.js] ← a.js 完成
T7:      [] ← main.js 完成
</code></pre>
<p>这种<strong>后进先出</strong>的执行顺序是ES模块系统的核心特征之一。</p>
<h3 id="2-绑定的活性live-bindings"><a class="header" href="#2-绑定的活性live-bindings">2. 绑定的活性（Live Bindings）</a></h3>
<pre><code class="language-javascript">// 展示ES模块活绑定如何帮助处理循环依赖

// counter.js
console.log('counter.js loading');
import { increment } from './utils.js';

export let count = 0;

export function getCount() {
    return count;
}

export function setCount(value) {
    count = value;
}

// 初始化时调用increment
increment();

// utils.js
console.log('utils.js loading');
import { count, setCount } from './counter.js';

export function increment() {
    console.log('increment called, current count:', count); // 初始时可能是0
    setCount(count + 1);
}

// main.js
import { getCount } from './counter.js';
import { increment } from './utils.js';

console.log('Initial count:', getCount()); // 1
increment();
console.log('After increment:', getCount()); // 2
</code></pre>
<h2 id="检测循环依赖"><a class="header" href="#检测循环依赖">检测循环依赖</a></h2>
<h3 id="1-静态分析工具"><a class="header" href="#1-静态分析工具">1. 静态分析工具</a></h3>
<pre><code class="language-javascript">// dependency-analyzer.js

class DependencyAnalyzer {
    constructor() {
        this.dependencies = new Map();
        this.visited = new Set();
        this.visiting = new Set();
    }
    
    addDependency(from, to) {
        if (!this.dependencies.has(from)) {
            this.dependencies.set(from, new Set());
        }
        this.dependencies.get(from).add(to);
    }
    
    findCircularDependencies() {
        const cycles = [];
        
        for (const module of this.dependencies.keys()) {
            if (!this.visited.has(module)) {
                const path = [];
                const cycle = this.dfs(module, path);
                if (cycle) {
                    cycles.push(cycle);
                }
            }
        }
        
        return cycles;
    }
    
    dfs(module, path) {
        if (this.visiting.has(module)) {
            // 找到循环依赖
            const cycleStart = path.indexOf(module);
            return path.slice(cycleStart).concat([module]);
        }
        
        if (this.visited.has(module)) {
            return null;
        }
        
        this.visiting.add(module);
        path.push(module);
        
        const dependencies = this.dependencies.get(module) || new Set();
        for (const dep of dependencies) {
            const cycle = this.dfs(dep, [...path]);
            if (cycle) {
                return cycle;
            }
        }
        
        this.visiting.delete(module);
        this.visited.add(module);
        path.pop();
        
        return null;
    }
    
    generateReport() {
        const cycles = this.findCircularDependencies();
        
        if (cycles.length === 0) {
            return 'No circular dependencies found.';
        }
        
        let report = `Found ${cycles.length} circular dependency(ies):\n\n`;
        
        cycles.forEach((cycle, index) =&gt; {
            report += `${index + 1}. ${cycle.join(' → ')}\n`;
        });
        
        return report;
    }
}

// 使用示例
const analyzer = new DependencyAnalyzer();

// 添加依赖关系
analyzer.addDependency('user.js', 'order.js');
analyzer.addDependency('order.js', 'product.js');
analyzer.addDependency('product.js', 'user.js');

console.log(analyzer.generateReport());
// 输出: Found 1 circular dependency(ies):
//       1. user.js → order.js → product.js → user.js
</code></pre>
<h3 id="2-运行时检测"><a class="header" href="#2-运行时检测">2. 运行时检测</a></h3>
<pre><code class="language-javascript">// runtime-cycle-detector.js

class RuntimeCycleDetector {
    constructor() {
        this.importStack = [];
        this.importGraph = new Map();
    }
    
    beforeImport(modulePath, currentModule) {
        // 检查是否形成循环
        if (this.importStack.includes(modulePath)) {
            const cycleStart = this.importStack.indexOf(modulePath);
            const cycle = this.importStack.slice(cycleStart).concat([modulePath]);
            
            console.warn('🔄 Circular dependency detected:', cycle.join(' → '));
            
            // 记录到图中
            this.recordCycle(cycle);
            
            return true; // 检测到循环
        }
        
        this.importStack.push(modulePath);
        return false; // 未检测到循环
    }
    
    afterImport(modulePath) {
        const index = this.importStack.indexOf(modulePath);
        if (index !== -1) {
            this.importStack.splice(index, 1);
        }
    }
    
    recordCycle(cycle) {
        const cycleKey = cycle.slice().sort().join('|');
        if (!this.importGraph.has(cycleKey)) {
            this.importGraph.set(cycleKey, {
                cycle: cycle,
                count: 1,
                firstDetected: new Date()
            });
        } else {
            this.importGraph.get(cycleKey).count++;
        }
    }
    
    getReport() {
        const cycles = Array.from(this.importGraph.values());
        
        if (cycles.length === 0) {
            return 'No circular dependencies detected during runtime.';
        }
        
        let report = 'Runtime Circular Dependencies Report:\n\n';
        
        cycles.forEach((info, index) =&gt; {
            report += `${index + 1}. ${info.cycle.join(' → ')}\n`;
            report += `   Detected ${info.count} time(s)\n`;
            report += `   First detected: ${info.firstDetected.toISOString()}\n\n`;
        });
        
        return report;
    }
}

// 创建全局检测器实例
const cycleDetector = new RuntimeCycleDetector();

// 模拟导入钩子（实际实现可能需要构建工具支持）
function importWithDetection(modulePath, currentModule) {
    const hasCycle = cycleDetector.beforeImport(modulePath, currentModule);
    
    if (hasCycle) {
        console.log(`⚠️  Proceeding with import despite circular dependency: ${modulePath}`);
    }
    
    // 执行实际导入
    const result = import(modulePath);
    
    cycleDetector.afterImport(modulePath);
    
    return result;
}
</code></pre>
<h2 id="循环依赖的解决方案"><a class="header" href="#循环依赖的解决方案">循环依赖的解决方案</a></h2>
<h3 id="1-重构消除循环依赖"><a class="header" href="#1-重构消除循环依赖">1. 重构消除循环依赖</a></h3>
<pre><code class="language-javascript">// 问题：用户和订单模块相互依赖

// 原始设计（有循环依赖）
// user.js
import { Order } from './order.js';

export class User {
    constructor(id, name) {
        this.id = id;
        this.name = name;
    }
    
    getOrders() {
        return Order.findByUserId(this.id);
    }
}

// order.js
import { User } from './user.js';

export class Order {
    constructor(id, userId, amount) {
        this.id = id;
        this.userId = userId;
        this.amount = amount;
    }
    
    getUser() {
        return User.findById(this.userId);
    }
    
    static findByUserId(userId) {
        // 查找逻辑
        return [];
    }
}

// 解决方案1：提取到服务层
// user.js
export class User {
    constructor(id, name) {
        this.id = id;
        this.name = name;
    }
}

// order.js
export class Order {
    constructor(id, userId, amount) {
        this.id = id;
        this.userId = userId;
        this.amount = amount;
    }
}

// user-service.js
import { User } from './user.js';
import { Order } from './order.js';

export class UserService {
    static async getUserWithOrders(userId) {
        const user = await User.findById(userId);
        const orders = await Order.findByUserId(userId);
        
        return {
            user,
            orders
        };
    }
    
    static async getOrderWithUser(orderId) {
        const order = await Order.findById(orderId);
        const user = await User.findById(order.userId);
        
        return {
            order,
            user
        };
    }
}
</code></pre>
<h3 id="2-依赖注入模式"><a class="header" href="#2-依赖注入模式">2. 依赖注入模式</a></h3>
<pre><code class="language-javascript">// dependency-injection.js

// 用户仓库
export class UserRepository {
    async findById(id) {
        // 数据库查询逻辑
        return { id, name: `User ${id}` };
    }
    
    async findByIds(ids) {
        return ids.map(id =&gt; ({ id, name: `User ${id}` }));
    }
}

// 订单仓库
export class OrderRepository {
    async findById(id) {
        return { id, userId: 1, amount: 100 };
    }
    
    async findByUserId(userId) {
        return [
            { id: 1, userId, amount: 100 },
            { id: 2, userId, amount: 200 }
        ];
    }
}

// 用户服务（注入订单仓库）
export class UserService {
    constructor(orderRepository) {
        this.orderRepository = orderRepository;
    }
    
    async getUserOrders(userId) {
        return this.orderRepository.findByUserId(userId);
    }
}

// 订单服务（注入用户仓库）
export class OrderService {
    constructor(userRepository) {
        this.userRepository = userRepository;
    }
    
    async getOrderUser(orderId) {
        const order = await this.findById(orderId);
        return this.userRepository.findById(order.userId);
    }
}

// 应用组装器（无循环依赖）
// app.js
import { UserRepository } from './user-repository.js';
import { OrderRepository } from './order-repository.js';
import { UserService } from './user-service.js';
import { OrderService } from './order-service.js';

export function createServices() {
    const userRepository = new UserRepository();
    const orderRepository = new OrderRepository();
    
    const userService = new UserService(orderRepository);
    const orderService = new OrderService(userRepository);
    
    return {
        userService,
        orderService,
        userRepository,
        orderRepository
    };
}
</code></pre>
<h3 id="3-事件驱动模式"><a class="header" href="#3-事件驱动模式">3. 事件驱动模式</a></h3>
<pre><code class="language-javascript">// event-driven.js

// 事件总线
class EventBus {
    constructor() {
        this.listeners = new Map();
    }
    
    on(event, callback) {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, []);
        }
        this.listeners.get(event).push(callback);
    }
    
    off(event, callback) {
        const callbacks = this.listeners.get(event);
        if (callbacks) {
            const index = callbacks.indexOf(callback);
            if (index &gt; -1) {
                callbacks.splice(index, 1);
            }
        }
    }
    
    emit(event, data) {
        const callbacks = this.listeners.get(event) || [];
        callbacks.forEach(callback =&gt; callback(data));
    }
}

export const eventBus = new EventBus();

// 用户模块（不直接依赖订单）
import { eventBus } from './event-bus.js';

export class User {
    constructor(id, name) {
        this.id = id;
        this.name = name;
    }
    
    static create(userData) {
        const user = new User(userData.id, userData.name);
        
        // 发布用户创建事件
        eventBus.emit('user:created', user);
        
        return user;
    }
    
    delete() {
        // 发布用户删除事件
        eventBus.emit('user:deleted', { userId: this.id });
    }
}

// 订单模块（通过事件响应用户变化）
import { eventBus } from './event-bus.js';

export class Order {
    constructor(id, userId, amount) {
        this.id = id;
        this.userId = userId;
        this.amount = amount;
    }
    
    static init() {
        // 监听用户删除事件
        eventBus.on('user:deleted', Order.handleUserDeleted);
    }
    
    static handleUserDeleted(data) {
        console.log(`Handling deletion of orders for user ${data.userId}`);
        // 处理用户删除后的订单清理逻辑
    }
}

// 初始化
Order.init();
</code></pre>
<h3 id="4-延迟导入模式"><a class="header" href="#4-延迟导入模式">4. 延迟导入模式</a></h3>
<pre><code class="language-javascript">// lazy-import.js

// 用户模块
export class User {
    constructor(id, name) {
        this.id = id;
        this.name = name;
    }
    
    async getOrders() {
        // 延迟导入订单模块
        const { OrderService } = await import('./order-service.js');
        return OrderService.findByUserId(this.id);
    }
}

// 订单模块
export class Order {
    constructor(id, userId, amount) {
        this.id = id;
        this.userId = userId;
        this.amount = amount;
    }
    
    async getUser() {
        // 延迟导入用户模块
        const { UserService } = await import('./user-service.js');
        return UserService.findById(this.userId);
    }
}

// 订单服务
export class OrderService {
    static findByUserId(userId) {
        // 查找逻辑
        return Promise.resolve([
            new Order(1, userId, 100),
            new Order(2, userId, 200)
        ]);
    }
}

// 用户服务
export class UserService {
    static findById(userId) {
        // 查找逻辑
        return Promise.resolve(new User(userId, `User ${userId}`));
    }
}
</code></pre>
<h3 id="5-中介者模式"><a class="header" href="#5-中介者模式">5. 中介者模式</a></h3>
<pre><code class="language-javascript">// mediator-pattern.js

// 中介者
export class AppMediator {
    constructor() {
        this.userService = null;
        this.orderService = null;
    }
    
    setUserService(userService) {
        this.userService = userService;
    }
    
    setOrderService(orderService) {
        this.orderService = orderService;
    }
    
    async getUserOrders(userId) {
        return this.orderService.findByUserId(userId);
    }
    
    async getOrderUser(orderId) {
        const order = await this.orderService.findById(orderId);
        return this.userService.findById(order.userId);
    }
    
    async getUserWithOrders(userId) {
        const user = await this.userService.findById(userId);
        const orders = await this.orderService.findByUserId(userId);
        
        return { user, orders };
    }
}

// 创建全局中介者实例
export const mediator = new AppMediator();

// 用户服务
import { mediator } from './mediator.js';

export class UserService {
    constructor() {
        mediator.setUserService(this);
    }
    
    async findById(id) {
        return { id, name: `User ${id}` };
    }
    
    async getUserOrders(userId) {
        return mediator.getUserOrders(userId);
    }
}

// 订单服务
import { mediator } from './mediator.js';

export class OrderService {
    constructor() {
        mediator.setOrderService(this);
    }
    
    async findById(id) {
        return { id, userId: 1, amount: 100 };
    }
    
    async findByUserId(userId) {
        return [
            { id: 1, userId, amount: 100 },
            { id: 2, userId, amount: 200 }
        ];
    }
    
    async getOrderUser(orderId) {
        return mediator.getOrderUser(orderId);
    }
}
</code></pre>
<h2 id="最佳实践"><a class="header" href="#最佳实践">最佳实践</a></h2>
<h3 id="1-设计原则"><a class="header" href="#1-设计原则">1. 设计原则</a></h3>
<pre><code class="language-javascript">// design-principles.js

// 原则1：单向依赖
// ✅ 好的设计
// domain/user.js
export class User {
    constructor(id, name) {
        this.id = id;
        this.name = name;
    }
}

// domain/order.js
import { User } from './user.js';  // 只依赖User，User不依赖Order

export class Order {
    constructor(id, user, amount) {
        this.id = id;
        this.user = user;  // 组合关系
        this.amount = amount;
    }
}

// 原则2：依赖于抽象而非具体实现
// services/user-service.js
export class UserService {
    constructor(userRepository) {  // 依赖抽象接口
        this.userRepository = userRepository;
    }
    
    async createUser(userData) {
        return this.userRepository.save(userData);
    }
}

// 原则3：分层架构
// 表现层 → 应用层 → 领域层 → 基础设施层
// 上层可以依赖下层，下层不应依赖上层
</code></pre>
<h3 id="2-模块组织策略"><a class="header" href="#2-模块组织策略">2. 模块组织策略</a></h3>
<pre><code class="language-javascript">// module-organization.js

// 策略1：按特性分组（Feature-based）
// features/
//   ├── user/
//   │   ├── user.model.js
//   │   ├── user.service.js
//   │   └── user.controller.js
//   ├── order/
//   │   ├── order.model.js
//   │   ├── order.service.js
//   │   └── order.controller.js
//   └── shared/
//       ├── event-bus.js
//       └── database.js

// 策略2：按层分组（Layer-based）
// src/
//   ├── models/
//   │   ├── user.js
//   │   └── order.js
//   ├── services/
//   │   ├── user-service.js
//   │   └── order-service.js
//   ├── controllers/
//   │   ├── user-controller.js
//   │   └── order-controller.js
//   └── shared/
//       └── interfaces.js

// 策略3：混合方式
// src/
//   ├── core/              # 核心业务逻辑
//   │   ├── user/
//   │   └── order/
//   ├── infrastructure/    # 基础设施
//   │   ├── database/
//   │   └── external-apis/
//   ├── application/       # 应用服务
//   │   └── use-cases/
//   └── presentation/      # 表现层
//       └── controllers/
</code></pre>
<h3 id="3-工具和配置"><a class="header" href="#3-工具和配置">3. 工具和配置</a></h3>
<pre><code class="language-javascript">// tools-config.js

// ESLint配置检测循环导入
// .eslintrc.js
module.exports = {
    plugins: ['import'],
    rules: {
        'import/no-cycle': ['error', { 
            maxDepth: 10,
            ignoreExternal: true 
        }]
    }
};

// Webpack配置显示循环依赖警告
// webpack.config.js
const CircularDependencyPlugin = require('circular-dependency-plugin');

module.exports = {
    plugins: [
        new CircularDependencyPlugin({
            exclude: /node_modules/,
            failOnError: true,
            allowAsyncCycles: false,
            cwd: process.cwd(),
        })
    ]
};

// 自定义检测脚本
// scripts/check-cycles.js
const madge = require('madge');

madge('./src')
    .then((res) =&gt; {
        const circular = res.circular();
        if (circular.length &gt; 0) {
            console.error('Circular dependencies found:');
            circular.forEach((cycle) =&gt; {
                console.error('  ', cycle.join(' → '));
            });
            process.exit(1);
        } else {
            console.log('✅ No circular dependencies found');
        }
    })
    .catch((err) =&gt; {
        console.error('Error analyzing dependencies:', err);
        process.exit(1);
    });
</code></pre>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>循环依赖虽然在ES模块中不会直接导致错误，但会增加代码的复杂性和维护难度：</p>
<ul>
<li>✅ <strong>理解ES模块行为</strong>: 掌握模块加载顺序和活绑定机制</li>
<li>✅ <strong>及早检测</strong>: 使用工具在开发阶段发现循环依赖</li>
<li>✅ <strong>重构设计</strong>: 通过分层、依赖注入等模式消除循环依赖</li>
<li>✅ <strong>采用最佳实践</strong>: 遵循单向依赖和分层架构原则</li>
<li>✅ <strong>选择合适策略</strong>: 根据项目特点选择适当的解决方案</li>
</ul>
<p>良好的模块设计应该避免循环依赖，这不仅提高了代码的可测试性和可维护性，也使应用架构更加清晰和稳定。</p>
<hr />
<p><strong>下一章</strong>: <a href="../cjs/basics.html">CommonJS基础</a> →</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../esm/hot-module-reload.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../cjs/basics.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../esm/hot-module-reload.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../cjs/basics.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
