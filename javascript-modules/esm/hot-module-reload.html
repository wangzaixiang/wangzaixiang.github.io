<!DOCTYPE HTML>
<html lang="zh-CN" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>热模块重载 - JavaScript 模块化开发指南</title>


        <!-- Custom HTML head -->

        <meta name="description" content="深入理解 JavaScript 模块系统：从基础概念到现代工具链">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">JavaScript 模块化开发指南</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="热模块重载-hot-module-reload"><a class="header" href="#热模块重载-hot-module-reload">热模块重载 (Hot Module Reload)</a></h1>
<p>热模块重载(HMR)是现代前端开发中的重要特性，允许在不刷新整个页面的情况下更新模块。它通过巧妙地绕过浏览器的模块缓存机制来实现实时开发体验。</p>
<h2 id="hmr基础概念"><a class="header" href="#hmr基础概念">HMR基础概念</a></h2>
<h3 id="核心价值"><a class="header" href="#核心价值">核心价值</a></h3>
<p>HMR解决了传统开发中的几个关键痛点：</p>
<pre><code class="language-javascript">// 传统开发流程的问题
// 1. 修改代码 → 2. 保存文件 → 3. 手动刷新浏览器 → 4. 重新填写表单/导航到测试页面
// 结果：开发效率低下，测试状态丢失

// HMR开发流程
// 1. 修改代码 → 2. 保存文件 → 3. 模块自动更新，状态保持
// 结果：即时反馈，开发体验显著提升
</code></pre>
<h3 id="浏览器模块缓存机制"><a class="header" href="#浏览器模块缓存机制">浏览器模块缓存机制</a></h3>
<pre><code class="language-javascript">// 浏览器模块缓存的工作原理
const moduleCache = new Map();

// 首次导入
import('./utils.js').then(module =&gt; {
    moduleCache.set('./utils.js', module); // 缓存模块
});

// 后续导入直接从缓存返回
import('./utils.js').then(module =&gt; {
    // 返回缓存的模块，即使文件已改变
});

// HMR的核心：绕过缓存
const versionedURL = `./utils.js?hmr_version=${Date.now()}`;
import(versionedURL).then(newModule =&gt; {
    // 强制获取新版本模块
});
</code></pre>
<h2 id="hmr的技术实现"><a class="header" href="#hmr的技术实现">HMR的技术实现</a></h2>
<h3 id="版本化url和websocket通信"><a class="header" href="#版本化url和websocket通信">版本化URL和WebSocket通信</a></h3>
<pre><code class="language-javascript">class HMRManager {
    constructor() {
        this.moduleVersions = new Map();
        this.moduleSubscribers = new Map();
        this.websocket = this.createWebSocket();
    }
    
    // 生成版本化的模块URL
    createVersionedURL(originalURL) {
        const version = this.moduleVersions.get(originalURL) || 0;
        const newVersion = version + 1;
        this.moduleVersions.set(originalURL, newVersion);
        
        // 添加版本参数绕过浏览器缓存
        const url = new URL(originalURL, window.location.origin);
        url.searchParams.set('hmr_version', newVersion.toString());
        url.searchParams.set('timestamp', Date.now().toString());
        
        return url.toString();
    }
    
    // 热重载指定模块
    async hotReload(modulePath) {
        console.log(`🔥 热重载模块: ${modulePath}`);
        
        try {
            const versionedURL = this.createVersionedURL(modulePath);
            const newModule = await import(versionedURL);
            
            // 通知所有订阅者
            const subscribers = this.moduleSubscribers.get(modulePath) || [];
            subscribers.forEach(callback =&gt; {
                try {
                    callback(newModule, modulePath);
                } catch (error) {
                    console.error(`HMR callback failed for ${modulePath}:`, error);
                }
            });
            
            return newModule;
        } catch (error) {
            console.error(`热重载失败 ${modulePath}:`, error);
            throw error;
        }
    }
    
    createWebSocket() {
        const ws = new WebSocket('ws://localhost:3000/hmr');
        
        ws.onmessage = (event) =&gt; {
            const message = JSON.parse(event.data);
            if (message.type === 'file-changed') {
                this.hotReload(message.path);
            }
        };
        
        ws.onopen = () =&gt; console.log('🔗 HMR WebSocket连接已建立');
        ws.onerror = (error) =&gt; console.error('❌ HMR WebSocket错误:', error);
        
        return ws;
    }
}
</code></pre>
<h2 id="live-binding问题与proxy解决方案"><a class="header" href="#live-binding问题与proxy解决方案">Live Binding问题与Proxy解决方案</a></h2>
<h3 id="live-binding在hmr中的核心问题"><a class="header" href="#live-binding在hmr中的核心问题">Live Binding在HMR中的核心问题</a></h3>
<pre><code class="language-mermaid">graph TD
    A[Module A&lt;br/&gt;静态导入] --&gt; B[Module B&lt;br/&gt;旧版本]
    C[HMR更新] --&gt; D[Module B'&lt;br/&gt;新版本]
    
    A -.-&gt;|❌ 仍然引用| B
    D -.-&gt;|✅ 需要重新绑定| A
    
    style B fill:#ff9999
    style D fill:#99ff99
    style A fill:#ffcc99
</code></pre>
<pre><code class="language-javascript">// 问题：静态导入的live binding在HMR中失效
import { calculateTotal, formatCurrency } from './utils.js';

class ProblematicShoppingCart {
    render() {
        // ❌ 这些函数引用在HMR后仍然指向旧版本！
        const total = calculateTotal(this.items);      // 旧版本
        const formattedTotal = formatCurrency(total);  // 旧版本
    }
}

// HMR更新后，即使utils.js文件内容改变了，
// calculateTotal和formatCurrency仍然是初始导入时的旧版本函数引用
</code></pre>
<h3 id="基于proxy的live-binding解决方案"><a class="header" href="#基于proxy的live-binding解决方案">基于Proxy的Live Binding解决方案</a></h3>
<pre><code class="language-javascript">// 核心：模块代理类
class ModuleProxy {
    constructor(modulePath) {
        this.modulePath = modulePath;
        this.currentModule = null;
        this.isLoading = false;
        this.loadInitialModule();
    }
    
    async loadInitialModule() {
        this.currentModule = await import(this.modulePath);
    }
    
    // 创建代理对象，动态转发到当前模块
    createProxy() {
        return new Proxy(this, {
            get(target, prop) {
                // 处理特殊属性
                if (prop === Symbol.toPrimitive || prop === 'valueOf' || prop === 'toString') {
                    return () =&gt; `[ModuleProxy: ${target.modulePath}]`;
                }
                
                if (target.currentModule &amp;&amp; prop in target.currentModule) {
                    const value = target.currentModule[prop];
                    
                    // 如果是函数，绑定正确的this并保持上下文
                    if (typeof value === 'function') {
                        return function(...args) {
                            return value.apply(target.currentModule, args);
                        };
                    }
                    
                    // 返回其他类型的值（变量、对象等）
                    return value;
                }
                
                return undefined;
            },
            
            // 支持 'prop' in proxy 检查
            has(target, prop) {
                return target.currentModule &amp;&amp; prop in target.currentModule;
            },
            
            // 支持 Object.keys(proxy) 等操作
            ownKeys(target) {
                return target.currentModule ? Object.keys(target.currentModule) : [];
            },
            
            getOwnPropertyDescriptor(target, prop) {
                if (target.currentModule &amp;&amp; prop in target.currentModule) {
                    return Object.getOwnPropertyDescriptor(target.currentModule, prop);
                }
                return undefined;
            }
        });
    }
    
    // HMR更新时调用
    async updateModule() {
        if (this.isLoading) return;
        
        this.isLoading = true;
        try {
            const versionedURL = `${this.modulePath}?hmr_version=${Date.now()}`;
            const newModule = await import(versionedURL);
            
            // 保存旧模块用于对比
            const oldModule = this.currentModule;
            this.currentModule = newModule;
            
            console.log('✅ 模块代理已更新，live binding已恢复');
            
            // 可选：输出变更信息
            this.logChanges(oldModule, newModule);
            
        } catch (error) {
            console.error('❌ 模块代理更新失败:', error);
            throw error;
        } finally {
            this.isLoading = false;
        }
    }
    
    // 对比并输出模块变更
    logChanges(oldModule, newModule) {
        if (!oldModule) return;
        
        const oldKeys = Object.keys(oldModule);
        const newKeys = Object.keys(newModule);
        
        const added = newKeys.filter(key =&gt; !oldKeys.includes(key));
        const removed = oldKeys.filter(key =&gt; !newKeys.includes(key));
        const changed = oldKeys.filter(key =&gt; {
            return newKeys.includes(key) &amp;&amp; oldModule[key] !== newModule[key];
        });
        
        if (added.length &gt; 0) console.log('➕ 新增导出:', added);
        if (removed.length &gt; 0) console.log('➖ 移除导出:', removed);
        if (changed.length &gt; 0) console.log('🔄 变更导出:', changed);
    }
}
</code></pre>
<h3 id="实际应用示例"><a class="header" href="#实际应用示例">实际应用示例</a></h3>
<pre><code class="language-javascript">// Module B: utils.js (被依赖的模块)
export function calculateTotal(items) {
    return items.reduce((sum, item) =&gt; sum + item.price * item.quantity, 0);
}

export function formatCurrency(amount) {
    return new Intl.NumberFormat('zh-CN', {
        style: 'currency',
        currency: 'CNY'
    }).format(amount);
}

// HMR处理
if (import.meta.hot) {
    import.meta.hot.accept((newModule) =&gt; {
        console.log('🔄 utils.js 已更新');
    });
}
</code></pre>
<pre><code class="language-javascript">// Module A: index.js - 使用Proxy方案
// 创建模块代理
const utilsProxy = new ModuleProxy('./utils.js');
const utils = utilsProxy.createProxy();

class SmartShoppingCart {
    constructor() {
        this.items = [
            { id: 1, name: '商品A', price: 100, quantity: 2 },
            { id: 2, name: '商品B', price: 50, quantity: 1 }
        ];
        this.render();
    }
    
    render() {
        // ✅ 通过代理访问，始终获取最新版本的函数
        const total = utils.calculateTotal(this.items);
        const formattedTotal = utils.formatCurrency(total);
        
        document.getElementById('cart').innerHTML = `
            &lt;div&gt;购物车总计: ${formattedTotal}&lt;/div&gt;
            &lt;div&gt;商品数量: ${this.items.length}&lt;/div&gt;
        `;
    }
}

// 全局实例管理
if (!window.__SMART_CART_INSTANCES__) {
    window.__SMART_CART_INSTANCES__ = [];
}

export function createShoppingCart() {
    const cart = new SmartShoppingCart();
    window.__SMART_CART_INSTANCES__.push(cart);
    return cart;
}

// HMR处理 - 使用Proxy方案
if (import.meta.hot) {
    import.meta.hot.accept(['./utils.js'], async () =&gt; {
        console.log('📦 utils.js 已更新，更新模块代理...');
        
        // 更新代理指向的模块
        await utilsProxy.updateModule();
        
        // 重新渲染所有实例，现在会使用新版本的函数
        window.__SMART_CART_INSTANCES__.forEach(cart =&gt; {
            cart.render();
        });
    });
}
</code></pre>
<h3 id="增强版proxy工厂"><a class="header" href="#增强版proxy工厂">增强版Proxy工厂</a></h3>
<pre><code class="language-javascript">// 高级模块代理工厂
class HMRModuleFactory {
    constructor() {
        this.proxies = new Map();
        this.hmrManager = new HMRManager();
    }
    
    // 创建或获取模块代理
    create(modulePath) {
        if (this.proxies.has(modulePath)) {
            return this.proxies.get(modulePath);
        }
        
        const moduleProxy = new ModuleProxy(modulePath);
        const proxy = moduleProxy.createProxy();
        
        // 注册HMR回调
        this.hmrManager.moduleSubscribers.set(modulePath, [
            async () =&gt; {
                await moduleProxy.updateModule();
                this.notifyUpdate(modulePath);
            }
        ]);
        
        this.proxies.set(modulePath, { proxy, moduleProxy });
        return proxy;
    }
    
    // 通知模块更新
    notifyUpdate(modulePath) {
        const event = new CustomEvent('hmr-module-updated', {
            detail: { modulePath, timestamp: Date.now() }
        });
        window.dispatchEvent(event);
    }
    
    // 获取所有代理的状态
    getProxyStatus() {
        const status = {};
        for (const [path, { moduleProxy }] of this.proxies) {
            status[path] = {
                isLoaded: !!moduleProxy.currentModule,
                isLoading: moduleProxy.isLoading,
                exports: moduleProxy.currentModule ? Object.keys(moduleProxy.currentModule) : []
            };
        }
        return status;
    }
}

// 全局工厂实例
const moduleFactory = new HMRModuleFactory();

// 便捷的模块导入函数
function hmrImport(modulePath) {
    return moduleFactory.create(modulePath);
}

// 使用示例
const utils = hmrImport('./utils.js');
const config = hmrImport('./config.js');
const helpers = hmrImport('./helpers.js');

// 监听模块更新事件
window.addEventListener('hmr-module-updated', (event) =&gt; {
    console.log(`📦 模块 ${event.detail.modulePath} 已通过HMR更新`);
});
</code></pre>
<h2 id="hmr的适用场景"><a class="header" href="#hmr的适用场景">HMR的适用场景</a></h2>
<h3 id="技术性变更-推荐使用hmr"><a class="header" href="#技术性变更-推荐使用hmr">技术性变更 (推荐使用HMR)</a></h3>
<pre><code class="language-javascript">// ✅ 性能优化 - API保持不变
// 优化前
export function calculateTotal(items) {
    let total = 0;
    for (let i = 0; i &lt; items.length; i++) {
        total += items[i].price * items[i].quantity;
    }
    return total;
}

// 优化后 - 使用更高效的reduce
export function calculateTotal(items) {
    return items.reduce((sum, item) =&gt; sum + item.price * item.quantity, 0);
}
</code></pre>
<h3 id="不适用的场景-推荐完整刷新"><a class="header" href="#不适用的场景-推荐完整刷新">不适用的场景 (推荐完整刷新)</a></h3>
<pre><code class="language-javascript">// ❌ API签名变更
// 变更前
export function calculateTotal(items) {
    return items.reduce((sum, item) =&gt; sum + item.price, 0);
}

// 变更后 - 签名改变，返回值类型改变
export function calculateTotal(items, options = {}) {
    const { tax = 0, discount = 0 } = options;
    const subtotal = items.reduce((sum, item) =&gt; sum + item.price, 0);
    return {
        subtotal,
        tax: subtotal * tax,
        total: subtotal * (1 + tax - discount)
    };
}
</code></pre>
<h3 id="hmr决策管理器"><a class="header" href="#hmr决策管理器">HMR决策管理器</a></h3>
<p>// FIXME replace with markdown table</p>
<pre><code class="language-javascript">class HMRDecisionManager {
    shouldUseHMR(changeType, moduleInfo) {
        const reasons = {
            // 技术性变更 - 适合HMR
            'performance_optimization': { useHMR: true, reason: '性能优化，API不变' },
            'bug_fix': { useHMR: true, reason: 'Bug修复，逻辑一致' },
            'code_refactoring': { useHMR: true, reason: '代码重构，接口稳定' },
            'style_update': { useHMR: true, reason: '样式更新，无副作用' },
            
            // 业务变更 - 需要完整刷新
            'api_signature_change': { useHMR: false, reason: 'API变更，避免类型错误' },
            'business_logic_change': { useHMR: false, reason: '业务逻辑变更，确保一致性' },
            'data_structure_change': { useHMR: false, reason: '数据结构变更，避免状态冲突' }
        };
        
        const decision = reasons[changeType] || { 
            useHMR: true, 
            reason: '默认尝试HMR，失败时降级' 
        };
        
        console.log(`📋 变更类型: ${changeType}`);
        console.log(`🎯 决策: ${decision.useHMR ? '使用HMR' : '完整刷新'}`);
        console.log(`💡 原因: ${decision.reason}`);
        
        return decision;
    }
}
</code></pre>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>热模块重载通过以下核心机制工作：</p>
<ol>
<li><strong>🔄 版本化URL</strong>: 绕过浏览器模块缓存，确保获取最新模块</li>
<li><strong>📡 WebSocket通信</strong>: 实时文件变更通知，保持客户端与服务器同步</li>
<li><strong>🎯 Proxy代理</strong>: 解决ES模块live binding问题，确保引用始终指向最新版本</li>
<li><strong>💾 状态保持</strong>: 维持应用运行时状态，避免开发时数据丢失</li>
</ol>
<h3 id="关键优势"><a class="header" href="#关键优势">关键优势</a></h3>
<ul>
<li><strong>⚡ 快速反馈</strong>: 代码变更即时可见</li>
<li><strong>🎯 精确更新</strong>: 只更新修改的模块</li>
<li><strong>💾 状态保持</strong>: 保持应用状态不丢失</li>
<li><strong>🔧 Live Binding</strong>: 通过Proxy确保始终访问最新模块</li>
</ul>
<h3 id="使用建议"><a class="header" href="#使用建议">使用建议</a></h3>
<ol>
<li><strong>Proxy方案</strong>: 对于复杂应用，使用基于Proxy的模块代理解决live binding问题</li>
<li><strong>适用场景</strong>: 优先用于技术性变更（性能优化、bug修复、代码重构）</li>
<li><strong>谨慎使用</strong>: 避免在业务逻辑变更和API签名变化时使用HMR</li>
<li><strong>错误处理</strong>: 实现完善的降级策略和错误恢复机制</li>
</ol>
<p>HMR是现代前端开发不可或缺的工具，而基于Proxy的live binding解决方案使其在复杂应用中也能稳定可靠地工作。</p>
<hr />
<p><strong>上一章</strong>: ← <a href="./resolution.html">模块解析机制</a></p>
<p><strong>下一章</strong>: <a href="./circular-deps.html">循环依赖处理</a> →</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../esm/resolution.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../esm/circular-deps.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../esm/resolution.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../esm/circular-deps.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
